 MODULE SUBS

#include <fftw3.f>
     ! OPTIONS:
! FFTW_ESTIMATE - a fast but probably inefficient FFT plan
! FFTW_MEASURE - does a few FFTs to gauge the machine speed
! FFTW_PATIENT - searches a range of algorithms to find the best one
! FFTW_EXHAUSTIVE - does a complete algorithm search, including some unlikely ones, to find the fastest. NB - may be slow to compute the plan.
  INTEGER, PARAMETER :: TRANSFORM_OPTIMISATION = FFTW_PATIENT  
  INTEGER( KIND = 8) ::  PLAN_FFT_R2HC

INTEGER, PARAMETER :: NTHETA_GRID_CONTOUR_GMT = 100, NPHI_GRID_CONTOUR_GMT = 200  !number of points for contour plots in GMT
INTEGER, PARAMETER :: GMT_THETA = 30, GMT_PHI = 30  !grid spacing for arrows in GMT plots
INTEGER, PARAMETER ::  NUMBER_RANDOM_START_PTS = 1000
INTEGER, PARAMETER :: TOROIDAL_FLOW = 1, POLOIDAL_FLOW = 2

TYPE HARMONIC_STRUCTURE
    INTEGER L, M
    INTEGER SINCOS
    END TYPE HARMONIC_STRUCTURE

INTEGER, PARAMETER :: EXTRA_LONG_REAL = 8, LONG_REAL = 8

REAL( KIND = LONG_REAL), ALLOCATABLE, DIMENSION(:,:) :: FFT_TRANSFORM_ARRAY

REAL( KIND = 8), PARAMETER :: CMB_RADIUS = 3485.0E3_8, ES_RADIUS = 6371.0E3_8, Pi = 3.14159265358979_8
INTEGER, PARAMETER :: COSINE_HARMONIC = 1, SINE_HARMONIC = 2

CONTAINS


SUBROUTINE GAUWTS ( NTHPTS, GAUX, GAUW )
      IMPLICIT NONE
! Computes the integration points and weights needed for Legendre transforms:

! INPUTS:
! NTHPTS    (INTEGER)
!           number of points in theta direction
! GAUX     ( REAL( KIND= LONG_REAL) ), dimension(1:NTHPTS)
!          The abscissae of the Gauss-Legendre integration, in cos(theta)
! GAUW     ( REAL( KIND= LONG_REAL) ), dimension(1:NTHPTS)
!          The weights of the Gauss-Legendre integration
!

      INTEGER NTHPTS
      REAL (KIND = EXTRA_LONG_REAL) GAUX( 1: NTHPTS ), GAUW( 1: NTHPTS )
      INTENT(IN) NTHPTS
      INTENT(OUT) GAUX, GAUW
!
      INTEGER M,I,J
      REAL (KIND = EXTRA_LONG_REAL) XM,XL,P1,P2,P3,EPS,PP,Z,Z1
      PARAMETER (EPS=1.0E-13_LONG_REAL)
      
      REAL (KIND = LONG_REAL), PARAMETER ::  X1 = -1.0_LONG_REAL, X2 = 1.0_LONG_REAL
    
! ....... the roots are symmetric in the interval so need only find
! half of them.
      M = ( NTHPTS + 1 )/2
      XM = 0.5_LONG_REAL * ( X2 + X1 )
      XL = 0.5_LONG_REAL * ( X2 - X1 )
! ........start looping over the desired roots .......................
      DO I = 1, M
         Z = COS( PI*( REAL (I, KIND = EXTRA_LONG_REAL) - 0.25_EXTRA_LONG_REAL)/( REAL(NTHPTS, KIND=EXTRA_LONG_REAL) + 0.5_EXTRA_LONG_REAL ))
!           ..... starting with this approximation to the Ith root, we
!                enter the main loop of refinement by Newton's method.
 100     CONTINUE
            P1 = 1.0_LONG_REAL
            P2 = 0.0_LONG_REAL
!           ........... Loop up the recurrence relation to get the
!                      legendre Polynomial evaluated at Z.
            DO J = 1, NTHPTS
               P3 = P2
               P2 = P1
               P1 = ((2.0_EXTRA_LONG_REAL*J-1.0_EXTRA_LONG_REAL)*Z*P2 - (J-1.0_EXTRA_LONG_REAL)*P3)/REAL( J, KIND=EXTRA_LONG_REAL )
            ENDDO
!           ..................... finish recurrence relation loop ...
! ... P1 is now the desired Legendre Polynomial. We now compute PP,
!    its derivative by a standard relation involving also P2, the 
!    polynomial of one order lower.
            PP = NTHPTS*(Z*P1-P2)/(Z*Z-1.0_EXTRA_LONG_REAL)
            Z1 = Z
            Z = Z1 - P1/PP
         IF ( ABS(Z-Z1).GT.EPS ) GOTO 100
! ...........scale the root to the desired interval .................
         GAUX( I ) = XM - XL*Z
! ...........and add its symmetric counterpart ......................
         GAUX( NTHPTS+1-I ) = XM + XL*Z
! ...........calculate the weight ...................................
         GAUW( I ) = 2.0_EXTRA_LONG_REAL*XL/((1.0_EXTRA_LONG_REAL-Z*Z)*PP*PP)
! ...........and add its symmetric counterpart ......................
         GAUW( NTHPTS + 1 - I ) = GAUW( I )

      ENDDO



! ......... end looping over the desired roots .......................
      RETURN
      END SUBROUTINE GAUWTS
!*********************************************************************

   SUBROUTINE GET_LEGENDRE_FUNCTIONS(COSTHETA_ARR, LMAX, MMAX, Y, dY)
IMPLICIT NONE
! Computes the required derivatives of the associated Legendre functions in EXTRA_LONG_REAL precision
! The arrays Y and dY are returned, which contain the elements
! P_l^m and d P_l^m/d theta in the harmonic ordering where
! the l's are consecutive
! Dimensions of Y etc. are: (grid, HARMONICS)
!
! Uses the recursion relations in A&S modified for fully normalised associated Legendre functions to compute
! P_m^m, P_m+1^m and then P_l^m.....
!
! Uses the recursion relation involving the derivative and multiple orders to compute d P_l^m / d(theta)


REAL (KIND = EXTRA_LONG_REAL) :: COSTHETA_ARR(1:)
INTEGER :: LMAX, MMAX
REAL (KIND = EXTRA_LONG_REAL) :: Y(1:,1:), dY(1:,1:)

REAL( KIND = EXTRA_LONG_REAL) ::  SINTHETA,PMM, PMM1, COSTHETA, FAC1, FAC2, SINSQINV, FACTOR
INTEGER :: NUM, INDEX, I, M , J, L

      DO I = 1, SIZE(COSTHETA_ARR)
      COSTHETA = COSTHETA_ARR(I)
      SINTHETA = SQRT( (1.0_EXTRA_LONG_REAL-COSTHETA) * (1.0_EXTRA_LONG_REAL + COSTHETA) ) 
      SINSQINV = 1.0_EXTRA_LONG_REAL / ( (1.0_EXTRA_LONG_REAL-COSTHETA) * (1.0_EXTRA_LONG_REAL + COSTHETA) )
      DO M = 0,MMAX
! Compute P_m^m
      PMM = 1.0_EXTRA_LONG_REAL
      NUM = 1
      DO J = 1, M
      PMM = PMM * SINTHETA * REAL(NUM, KIND = EXTRA_LONG_REAL) / SQRT( REAL( NUM*(NUM+1), KIND = EXTRA_LONG_REAL) )
      NUM = NUM + 2
      ENDDO
! renormalise to "fully normalised" functions
      PMM = PMM * SQRT( 0.5_EXTRA_LONG_REAL * REAL( 2 * M + 1, KIND = EXTRA_LONG_REAL) )
      
      IF(M .eq. LMAX) THEN
      INDEX = SIZE(Y,2)
      Y(I,INDEX) = PMM  !P_LMAX^LMAX
      EXIT !end of loop
      ENDIF
      L = M
      INDEX = M * LMAX +  (M * (3-M) ) /2 + 1 + (L - M)
      Y(I,INDEX) = PMM            
! Compute P_{m+1}^m
      PMM1 = COSTHETA * REAL( 2*M + 1, KIND = EXTRA_LONG_REAL) * PMM
! renormalise to "fully normalised" functions
      PMM1 = PMM1 * SQRT( REAL( 2 * M + 3, KIND = EXTRA_LONG_REAL) ) / REAL( 2*M+1, KIND = EXTRA_LONG_REAL)
      IF( M .eq. LMAX - 1) THEN
      INDEX = SIZE(Y,2)-1
      Y(I,INDEX) = PMM1 ! P_LMAX^LMAX-1
      CYCLE !next M
      ENDIF
        L = M + 1
        INDEX = M * LMAX +  (M * (3-M) ) /2 + 1 + (L - M)
        Y(I,INDEX) = PMM1 ! P_M+1^M
        DO L = M+2, LMAX
        INDEX = M * LMAX +  (M * (3-M) ) /2 + 1 + (L - M)
	FAC1 = REAL( (2 * L + 1) * (L-M) , KIND = EXTRA_LONG_REAL)  / REAL( (2*L-1)*(L+M), KIND = EXTRA_LONG_REAL)
	FAC1 = SQRT( FAC1 )
	FAC2 = REAL( (2 * L + 1) * (L-M) * (L-M-1) , KIND = EXTRA_LONG_REAL)  / REAL( (2*L-3)*(L+M)*(L+M-1), KIND = EXTRA_LONG_REAL)
	FAC2 = SQRT( FAC2 )
	Y(I,INDEX) = (FAC1 * COSTHETA * REAL( 2*L - 1, KIND = EXTRA_LONG_REAL) * Y(I,INDEX-1) - &
	FAC2 * REAL( L + M - 1, KIND = EXTRA_LONG_REAL) * Y(I,INDEX-2) ) / REAL( L - M, KIND = EXTRA_LONG_REAL)
	ENDDO

       ENDDO !M
      

! Compute derivatives:
      DO M = 0, MMAX
      DO L = M, LMAX
      INDEX = M * LMAX +  (M * (3-M) ) /2 + 1 + (L - M)
      IF( M .eq. L) THEN
      dY(I,INDEX) = REAL(L, KIND = EXTRA_LONG_REAL) * COSTHETA / SINTHETA * Y(I, INDEX )
      ELSE
      dY(I, INDEX) = REAL(L, KIND = EXTRA_LONG_REAL) * COSTHETA / SINTHETA * Y( I, INDEX ) - &
                    REAL(L+M ,KIND = EXTRA_LONG_REAL) * &
		    SQRT( REAL( (2*L+1)*(L-M), KIND = EXTRA_LONG_REAL) / REAL( (2*L-1) * (L+M), KIND= EXTRA_LONG_REAL) ) * &
		    Y( I, INDEX-1 ) / SINTHETA 
       ENDIF
       
		      
       ENDDO
       ENDDO
       
        ENDDO !I

  

 ! Renormalise so that the harmonics are Schmidt quasi-normalised.
 
      DO M = 0,MMAX
      DO L = M, LMAX
      INDEX = M * LMAX +  (M * (3-M) ) /2 + 1 + (L - M)
      IF( M .eq. 0) THEN
      FACTOR = SQRT(2.0_EXTRA_LONG_REAL/ REAL(2 * L + 1, KIND = EXTRA_LONG_REAL) )
      ELSE
      FACTOR = SQRT(4.0_EXTRA_LONG_REAL  / REAL(2 * L + 1, KIND = EXTRA_LONG_REAL) )
      ENDIF
      Y(:,INDEX) = Y(:,INDEX) * FACTOR
      DY(:,INDEX) = DY(:,INDEX) * FACTOR
      ENDDO
      ENDDO

 ! PRINT*, 'here', Y(1,9), COSTHETA_ARR(1), ACOS( COSTHETA_ARR(1))

  RETURN
END SUBROUTINE GET_LEGENDRE_FUNCTIONS

   SUBROUTINE EVALUATE_B_R_GRID( NTHETA_GRID, NPHI_GRID, GAUSS, HARMONICS, LMAX_B_OBS, LMAX, B_R, GRAD_H_B_R, ALF, DALF, ONE_DIV_SINTHETA )
! Evaluates B_r on the CMB on the defined (theta,phi) grid, along with its horizontal derivatives.

   IMPLICIT NONE
   INTEGER :: NTHETA_GRID, NPHI_GRID, LMAX, LMAX_B_OBS
   REAL( KIND = EXTRA_LONG_REAL) :: GAUSS(1:), B_R(1:,0:),  GRAD_H_B_R(1:,0:,1:), ALF(1:,1:), DALF(1:,1:), ONE_DIV_SINTHETA(1:)
   TYPE (HARMONIC_STRUCTURE) :: HARMONICS(1:)

   INTEGER :: I, INDEX_PLM, I_THETA, I_PHI

   REAL( KIND = EXTRA_LONG_REAL) :: PHI_DEP, DERV_PHI_DEP, PHI

   GRAD_H_B_R(:,:,:) = 0.0_EXTRA_LONG_REAL
   B_R(:,:) = 0.0_EXTRA_LONG_REAL

   DO I_THETA = 1, NTHETA_GRID
   DO I_PHI = 0, NPHI_GRID - 1
   PHI = I_PHI * 2.0_EXTRA_LONG_REAL * Pi / REAL(NPHI_GRID, KIND = EXTRA_LONG_REAL)

   DO I = 1, SIZE(HARMONICS)
   IF( HARMONICS(I)%L .GT. LMAX_B_OBS ) CYCLE

    IF( HARMONICS(I)%SINCOS .EQ. SINE_HARMONIC ) THEN
    PHI_DEP = SIN(  HARMONICS(I)%M * PHI  )
    DERV_PHI_DEP = HARMONICS(I)%M * COS(  HARMONICS(I)%M * PHI )
    ELSE
    PHI_DEP = COS(  HARMONICS(I)%M * PHI )
    DERV_PHI_DEP = -HARMONICS(I)%M * SIN(  HARMONICS(I)%M * PHI)
    ENDIF

    INDEX_PLM = HARMONICS(I)%M * LMAX +  (HARMONICS(I)%M * (3-HARMONICS(I)%M) ) /2 + 1 + (HARMONICS(I)%L - HARMONICS(I)%M)
    B_R( I_THETA, I_PHI ) = B_R( I_THETA, I_PHI )  + GAUSS(I) * (ES_RADIUS /CMB_RADIUS)**(HARMONICS(I)%L + 2) * (HARMONICS(I)%L + 1) * ALF(I_THETA, INDEX_PLM) * PHI_DEP
    GRAD_H_B_R( I_THETA, I_PHI, 1) = GRAD_H_B_R( I_THETA, I_PHI, 1) + GAUSS(I) *(ES_RADIUS /CMB_RADIUS)**(HARMONICS(I)%L + 2) * (HARMONICS(I)%L + 1) * DALF(I_THETA, INDEX_PLM) * PHI_DEP / CMB_RADIUS
    GRAD_H_B_R( I_THETA, I_PHI, 2) = GRAD_H_B_R( I_THETA, I_PHI, 2) + GAUSS(I) * (ES_RADIUS /CMB_RADIUS)**(HARMONICS(I)%L + 2) * (HARMONICS(I)%L + 1) * ALF(I_THETA, INDEX_PLM) * DERV_PHI_DEP * ONE_DIV_SINTHETA(I_THETA) / CMB_RADIUS
   ENDDO
   
   ENDDO
   ENDDO 
   RETURN
   END SUBROUTINE EVALUATE_B_R_GRID

   
   
   
   SUBROUTINE EVALUATE_B_SURF_GRID( NTHETA_GRID, NPHI_GRID, GAUSS, HARMONICS, LMAX_B_OBS, LMAX, B_R_SURF, B_T_SURF, B_P_SURF, ALF, DALF, ONE_DIV_SINTHETA )
! Evaluates B at the Earth's surface on the defined (theta,phi) grid

   IMPLICIT NONE
   INTEGER :: NTHETA_GRID, NPHI_GRID, LMAX, LMAX_B_OBS
   REAL( KIND = EXTRA_LONG_REAL) :: GAUSS(1:), B_R_SURF(1:,0:),  B_T_SURF(1:,0:), B_P_SURF(1:,0:), ALF(1:,1:), DALF(1:,1:), ONE_DIV_SINTHETA(1:)
   TYPE (HARMONIC_STRUCTURE) :: HARMONICS(1:)

   INTEGER :: I, INDEX_PLM, I_THETA, I_PHI

   REAL( KIND = EXTRA_LONG_REAL) :: PHI_DEP, DERV_PHI_DEP, PHI

   B_R_SURF(:,:) = 0.0_EXTRA_LONG_REAL
   B_T_SURF(:,:) = 0.0_EXTRA_LONG_REAL
   B_P_SURF(:,:) = 0.0_EXTRA_LONG_REAL

   DO I_THETA = 1, NTHETA_GRID
   DO I_PHI = 0, NPHI_GRID - 1
   PHI = I_PHI * 2.0_EXTRA_LONG_REAL * Pi / REAL(NPHI_GRID, KIND = EXTRA_LONG_REAL)

   DO I = 1, SIZE(HARMONICS)
   IF( HARMONICS(I)%L .GT. LMAX_B_OBS ) CYCLE

    IF( HARMONICS(I)%SINCOS .EQ. SINE_HARMONIC ) THEN
    PHI_DEP = SIN(  HARMONICS(I)%M * PHI  )
    DERV_PHI_DEP = HARMONICS(I)%M * COS(  HARMONICS(I)%M * PHI )
    ELSE
    PHI_DEP = COS(  HARMONICS(I)%M * PHI )
    DERV_PHI_DEP = -HARMONICS(I)%M * SIN(  HARMONICS(I)%M * PHI)
    ENDIF

    INDEX_PLM = HARMONICS(I)%M * LMAX +  (HARMONICS(I)%M * (3-HARMONICS(I)%M) ) /2 + 1 + (HARMONICS(I)%L - HARMONICS(I)%M)
    B_R_SURF( I_THETA, I_PHI ) = B_R_SURF( I_THETA, I_PHI ) + GAUSS(I) * (HARMONICS(I)%L + 1) * ALF(I_THETA, INDEX_PLM) * PHI_DEP
    B_T_SURF( I_THETA, I_PHI ) = B_T_SURF( I_THETA, I_PHI ) - GAUSS(I) * DALF(I_THETA, INDEX_PLM) * PHI_DEP
    B_P_SURF( I_THETA, I_PHI ) = B_P_SURF( I_THETA, I_PHI ) - GAUSS(I) * ALF(I_THETA, INDEX_PLM) * DERV_PHI_DEP * ONE_DIV_SINTHETA(I_THETA)
   ENDDO

   ENDDO
   ENDDO
   RETURN
   END SUBROUTINE EVALUATE_B_SURF_GRID

   
   SUBROUTINE EVALUATE_NABLA2_B_R_GRID( NTHETA_GRID, NPHI_GRID, GAUSS, HARMONICS, LMAX_B_OBS, LMAX, NABLA2_B_R, ALF )
! caclulate horizontal laplacian of function B_r at the CMB from the gauss coefficients
   IMPLICIT NONE
   INTEGER :: NTHETA_GRID, NPHI_GRID, LMAX, LMAX_B_OBS
   REAL( KIND = EXTRA_LONG_REAL) :: GAUSS(1:), NABLA2_B_R(1:,0:), ALF(1:,1:)
   TYPE (HARMONIC_STRUCTURE) :: HARMONICS(1:)

   INTEGER :: I, INDEX_PLM, I_THETA, I_PHI

   REAL( KIND = EXTRA_LONG_REAL) :: PHI_DEP, DERV_PHI_DEP, PHI

   NABLA2_B_R(:,:) = 0.0_LONG_REAL
   
   DO I_THETA = 1, NTHETA_GRID
   DO I_PHI = 0, NPHI_GRID - 1
   PHI = I_PHI * 2.0_LONG_REAL * Pi / REAL(NPHI_GRID, KIND = EXTRA_LONG_REAL)

   DO I = 1, SIZE(HARMONICS)
   IF( HARMONICS(I)%L .GT. LMAX_B_OBS ) CYCLE

    IF( HARMONICS(I)%SINCOS .EQ. SINE_HARMONIC ) THEN
    PHI_DEP = SIN(  HARMONICS(I)%M * PHI  )
    DERV_PHI_DEP = HARMONICS(I)%M * COS(  HARMONICS(I)%M * PHI )
    ELSE
    PHI_DEP = COS(  HARMONICS(I)%M * PHI )
    DERV_PHI_DEP = -HARMONICS(I)%M * SIN(  HARMONICS(I)%M * PHI)
    ENDIF

    INDEX_PLM = HARMONICS(I)%M * LMAX +  (HARMONICS(I)%M * (3-HARMONICS(I)%M) ) /2 + 1 + (HARMONICS(I)%L - HARMONICS(I)%M)
    NABLA2_B_R( I_THETA, I_PHI ) = NABLA2_B_R( I_THETA, I_PHI )  - GAUSS(I) * (1/CMB_RADIUS)**2 * (ES_RADIUS /CMB_RADIUS)**(HARMONICS(I)%L + 2) * HARMONICS(I)%L *(HARMONICS(I)%L + 1)**2 * ALF(I_THETA, INDEX_PLM) * PHI_DEP
   ENDDO

   ENDDO
   ENDDO
   
   END SUBROUTINE EVALUATE_NABLA2_B_R_GRID
   
   

  SUBROUTINE EVALUATE_U_H_SINGLE_HARMONIC( NTHETA_GRID, NPHI_GRID, I_HARMONIC, I_TYPE, U_H, DIV_H_U_H, ALF, DALF, HARMONICS, LMAX, ONE_DIV_SIN_THETA, COSTHETA_GRID  )
! Evaluates u_H on the defined (theta,phi) grid, along with its horizontal divergence.
! if harmonic is -1, then evaluate all harmonics.

! div_h . u_h = d(u_theta)/d theta + cot(theta) * u_theta + 1/sin(theta) * d(u_phi)/d phi

   IMPLICIT NONE
   INTEGER :: NTHETA_GRID, NPHI_GRID, I_HARMONIC, I_TYPE, LMAX
   REAL( KIND = EXTRA_LONG_REAL) ::  U_H(1:,0:,1:),  DIV_H_U_H(1:,0:), ALF(1:,1:), DALF(1:,1:), ONE_DIV_SIN_THETA(1:), COSTHETA_GRID(1:)
   TYPE (HARMONIC_STRUCTURE) :: HARMONICS(1:)
 
    INTEGER :: INDEX, I_THETA, I_PHI, J, LOWER_HARMONIC, UPPER_HARMONIC
    REAL( KIND = EXTRA_LONG_REAL) :: PHI, DERV_PHI_DEP, PHI_DEP

   
   U_H(:,:,:) = 0.0_LONG_REAL

   IF(I_TYPE .eq. TOROIDAL_FLOW) THEN
  
   DO I_THETA = 1, NTHETA_GRID
   DO I_PHI = 0, NPHI_GRID - 1
   PHI = I_PHI * 2.0_LONG_REAL * Pi / REAL(NPHI_GRID, KIND = EXTRA_LONG_REAL)
 
    J = I_HARMONIC
    INDEX = HARMONICS(J)%M * LMAX +  (HARMONICS(J)%M * (3-HARMONICS(J)%M) ) /2 + 1 + (HARMONICS(J)%L - HARMONICS(J)%M)

    IF( HARMONICS(J)%SINCOS .EQ. SINE_HARMONIC ) THEN
    PHI_DEP = SIN(  HARMONICS(J)%M * PHI  )
    DERV_PHI_DEP = HARMONICS(J)%M * COS(  HARMONICS(J)%M * PHI )
    ELSE
    PHI_DEP = COS(  HARMONICS(J)%M * PHI )
    DERV_PHI_DEP = -HARMONICS(J)%M * SIN(  HARMONICS(J)%M * PHI)
    ENDIF

   U_H(I_THETA, I_PHI,1) =  DERV_PHI_DEP * ALF(I_THETA, INDEX) * ONE_DIV_SIN_THETA(I_THETA)
   U_H(I_THETA, I_PHI,2) = - PHI_DEP * DALF(I_THETA, INDEX)

  
   ENDDO
   ENDDO

   DIV_H_U_H(:,:) = 0.0_LONG_REAL
! surface divergence of toroidal flow is zero.

   ELSE ! poloidal flow
 
   DO I_THETA = 1, NTHETA_GRID
   DO I_PHI = 0, NPHI_GRID - 1
   PHI = I_PHI * 2.0_LONG_REAL * Pi / REAL(NPHI_GRID, KIND = EXTRA_LONG_REAL)
 
    J = I_HARMONIC
    INDEX = HARMONICS(J)%M * LMAX +  (HARMONICS(J)%M * (3-HARMONICS(J)%M) ) /2 + 1 + (HARMONICS(J)%L - HARMONICS(J)%M)

    IF( HARMONICS(J)%SINCOS .EQ. SINE_HARMONIC ) THEN
    PHI_DEP = SIN(  HARMONICS(J)%M * PHI  )
    DERV_PHI_DEP = HARMONICS(J)%M * COS(  HARMONICS(J)%M * PHI )
    ELSE
    PHI_DEP = COS(  HARMONICS(J)%M * PHI )
    DERV_PHI_DEP = -HARMONICS(J)%M * SIN(  HARMONICS(J)%M * PHI)
    ENDIF

   U_H(I_THETA, I_PHI,1) =  PHI_DEP * DALF(I_THETA, INDEX)
   U_H(I_THETA, I_PHI,2) =  DERV_PHI_DEP * ALF(I_THETA, INDEX) * ONE_DIV_SIN_THETA(I_THETA)
   
   DIV_H_U_H(I_THETA, I_PHI) = - ALF(I_THETA, INDEX) * PHI_DEP * REAL( HARMONICS(J)%L * ( HARMONICS(J)%L + 1), KIND = LONG_REAL ) / CMB_RADIUS

! surface divergence of poloidal flow is -l(l+1)/r for each harmonic
  
   ENDDO
   ENDDO

 !  IF( I_THETA .eq. 1 .and. I_PHI .eq. 1) THEN
 !  PRINT*, U_H(1,1,1:2),  DIV_H_U_H(1,1)
 !  STOP
 !  ENDIF



   ENDIF   

   !PRINT*,'HERE', DERV_PHI_DEP , -M * SIN(  HARMONICS(I_HARMONIC)%M * PHI)
   RETURN
   END SUBROUTINE EVALUATE_U_H_SINGLE_HARMONIC

   SUBROUTINE  EVALUATE_U_H( NTHETA_GRID, NPHI_GRID, SPEC_TOR, SPEC_POL, U_H, DIV_H_U_H, ALF, DALF, HARMONICS, LMAX_U, LMAX_SV, ONE_DIV_SIN_THETA  ) 
   
! Evaluates u_H on the defined (theta,phi) grid

   IMPLICIT NONE
   INTEGER :: NTHETA_GRID, NPHI_GRID, I_HARMONIC, I_TYPE, LMAX_U, LMAX_SV
   REAL( KIND = EXTRA_LONG_REAL) ::  U_H(1:,0:,1:), ALF(1:,1:), DALF(1:,1:), ONE_DIV_SIN_THETA(1:), SPEC_TOR(1:),SPEC_POL(1:), DIV_H_U_H(1:,0:)
   TYPE (HARMONIC_STRUCTURE) :: HARMONICS(1:)
 
    INTEGER :: INDEX, I_THETA, I_PHI, J
    REAL( KIND = EXTRA_LONG_REAL) :: PHI, DERV_PHI_DEP, PHI_DEP

   
   U_H(:,:,:) = 0.0_LONG_REAL
   DIV_H_U_H(:,:) = 0.0_LONG_REAL
    
   DO I_THETA = 1, NTHETA_GRID
   DO I_PHI = 0, NPHI_GRID - 1
   PHI = I_PHI * 2.0_LONG_REAL * Pi / REAL(NPHI_GRID, KIND = EXTRA_LONG_REAL)

   DO I_HARMONIC = 1, LMAX_U * (LMAX_U + 2)

    INDEX = HARMONICS(I_HARMONIC)%M * LMAX_SV +  (HARMONICS(I_HARMONIC)%M * (3-HARMONICS(I_HARMONIC)%M) ) /2 + 1 + (HARMONICS(I_HARMONIC)%L - HARMONICS(I_HARMONIC)%M)

    IF( HARMONICS(I_HARMONIC)%SINCOS .EQ. SINE_HARMONIC ) THEN
    PHI_DEP = SIN(  HARMONICS(I_HARMONIC)%M * PHI  )
    DERV_PHI_DEP = HARMONICS(I_HARMONIC)%M * COS(  HARMONICS(I_HARMONIC)%M * PHI )
    ELSE
    PHI_DEP = COS(  HARMONICS(I_HARMONIC)%M * PHI )
    DERV_PHI_DEP = -HARMONICS(I_HARMONIC)%M * SIN(  HARMONICS(I_HARMONIC)%M * PHI)
    ENDIF

! toroidal
   U_H(I_THETA, I_PHI,1) = U_H(I_THETA, I_PHI,1) + SPEC_TOR(I_HARMONIC) * DERV_PHI_DEP * ALF(I_THETA, INDEX) * ONE_DIV_SIN_THETA(I_THETA)
   U_H(I_THETA, I_PHI,2) = U_H(I_THETA, I_PHI,2) - SPEC_TOR(I_HARMONIC) * PHI_DEP * DALF(I_THETA, INDEX)
  
! poloidal
   
   U_H(I_THETA, I_PHI,1) = U_H(I_THETA, I_PHI,1) + SPEC_POL(I_HARMONIC) * PHI_DEP * DALF(I_THETA, INDEX)
   U_H(I_THETA, I_PHI,2) = U_H(I_THETA, I_PHI,2) + SPEC_POL(I_HARMONIC) * DERV_PHI_DEP * ALF(I_THETA, INDEX) * ONE_DIV_SIN_THETA(I_THETA)
  

   DIV_H_U_H(I_THETA, I_PHI) = DIV_H_U_H(I_THETA, I_PHI) - SPEC_POL(I_HARMONIC) * ALF(I_THETA, INDEX) * PHI_DEP * REAL( HARMONICS(I_HARMONIC)%L * ( HARMONICS(I_HARMONIC)%L + 1), KIND = EXTRA_LONG_REAL ) / CMB_RADIUS
   
   ENDDO 
   ENDDO
   ENDDO

     
   
   RETURN
   END SUBROUTINE EVALUATE_U_H


    SUBROUTINE REAL_2_SPEC( REAL_SPACE, SPEC, LMAX, LMAX_TRANSFORM, HARMONICS, NPHI_GRID, NTHETA_GRID, LEGENDRE_INV )
! Projects a scalar quantity defined on a grid onto Schmidt quasi-normalised spherical harmonics

   IMPLICIT NONE
   INTEGER :: NTHETA_GRID, NPHI_GRID
   REAL( KIND = EXTRA_LONG_REAL) ::  REAL_SPACE(1:,0:), SPEC(1:), LEGENDRE_INV(1:,1:)
   TYPE (HARMONIC_STRUCTURE) :: HARMONICS(1:)

! Computes the spherical harmonic coefficients from Y_0^0 up to L,M = LMAX_TRANSFORM.

! LMAX is the maximum degree with which the array SPEC is defined. If LMAX_TRANSFORM < LMAX then the SPEC array is padded with zeros.
      
      REAL ( KIND = EXTRA_LONG_REAL) :: PHI_FAC
      INTEGER :: INDEX_PLM, I
      
      INTEGER :: LMAX, LMAX_TRANSFORM, MMAX, I_HARMONIC
     !  REAL_SPACE(:,:) = 1.0

    !   PRINT*, 'SLOW1', SUM( REAL_SPACE(1,:) ) / NPHI_GRID
! FFT     
      FFT_TRANSFORM_ARRAY(1:NTHETA_GRID,0:NPHI_GRID-1) = REAL_SPACE(:,:)
      CALL DFFTW_EXECUTE(PLAN_FFT_R2HC) 
      REAL_SPACE(:,:) = FFT_TRANSFORM_ARRAY(1:NTHETA_GRID,0:NPHI_GRID-1)    
     
      
      !PRINT*, 'FAST1', REAL_SPACE(1,0)

     ! PRINT*,  REAL_SPACE(:,1); PRINT*, REAL_SPACE(:,1) * 1.0_LONG_REAL * Pi / REAL( NPHI_GRID, KIND = LONG_REAL); STOP !; PRINT*, LEGENDRE_INV(1:NTHETA_GRID,19); PRINT*, SUM( REAL_SPACE(:,2) * LEGENDRE_INV(1:NTHETA_GRID,19)); STOP
! Legendre transform
       SPEC(:) = 0.0_LONG_REAL
       DO I =  1, LMAX_TRANSFORM * (LMAX_TRANSFORM + 2)
! Recall that 
! cos(m phi), m=1,2,3,4 is stored in the m^{th} element as 0.5
! sin(m phi), m=1,2,3,4 is stored in the (NPHI_GRID-m)^{th} element as -0.5    
! cos(0 phi)  is stored in the 0^{th} element as 1

      
      !PHI_FAC = 2.0_LONG_REAL * Pi / REAL( NPHI_GRID, KIND = EXTRA_LONG_REAL)
      !PHI_FAC = PHI_FAC / ( 4.0_LONG_REAL * Pi / REAL( 2 * HARMONICS(I)%L + 1, KIND = EXTRA_LONG_REAL ) )

       PHI_FAC = 0.5_LONG_REAL * REAL( 2 * HARMONICS(I)%L + 1, KIND = EXTRA_LONG_REAL) / REAL( NPHI_GRID, KIND = LONG_REAL) 

      INDEX_PLM = HARMONICS(I)%M * LMAX +  (HARMONICS(I)%M * (3-HARMONICS(I)%M) ) /2 + 1 + (HARMONICS(I)%L - HARMONICS(I)%M)

      IF( HARMONICS(I)%SINCOS .EQ. COSINE_HARMONIC) THEN
      SPEC( I ) = PHI_FAC  * SUM(  REAL_SPACE(1:NTHETA_GRID,HARMONICS(I)%M) * LEGENDRE_INV(1:NTHETA_GRID,INDEX_PLM) )
      ELSE
      SPEC( I ) = -PHI_FAC  * SUM(  REAL_SPACE(1:NTHETA_GRID,NPHI_GRID-HARMONICS(I)%M) * LEGENDRE_INV(1:NTHETA_GRID,INDEX_PLM) )
      ENDIF
       
     
      ENDDO
         		    
      RETURN
      END SUBROUTINE REAL_2_SPEC

   SUBROUTINE WRITE_U_GMT( GMT_THETA, GMT_PHI, EVEC_TOR,  EVEC_POL, HARMONICS, LMAX, SCALE_FACTOR ) 
! Writes the flow to a file that GMT can read. Expects u to describe a flow in units of km/yr

      IMPLICIT NONE
      INTEGER ::  GMT_THETA, GMT_PHI,  LMAX 
      REAL( KIND = EXTRA_LONG_REAL) :: EVEC_TOR(1:), EVEC_POL(1:)
      REAL( KIND = LONG_REAL) :: SCALE_FACTOR
      TYPE ( HARMONIC_STRUCTURE ) :: HARMONICS(1:)

      REAL( KIND = EXTRA_LONG_REAL), ALLOCATABLE :: COSTHETA_GRID(:), ALF(:,:), DALF(:,:), ONE_DIV_SIN_THETA(:), U_H(:,:,:)
      REAL( KIND = EXTRA_LONG_REAL), ALLOCATABLE :: TEMP_THETA_TRANSFORM_ALF(:,:), TEMP_THETA_TRANSFORM_DALF(:,:)
      REAL( KIND = EXTRA_LONG_REAL) :: PHI, ANGLE_VEC, MOD_VEC, PHI_DEP, DERV_PHI_DEP
      INTEGER :: I_THETA, I_PHI, I_HARMONIC, INDEX
  
! setup grids
      ALLOCATE( COSTHETA_GRID(1: GMT_THETA))
      DO I_THETA = 1, GMT_THETA
       COSTHETA_GRID(I_THETA) = COS(  I_THETA / REAL( GMT_THETA + 1, KIND = EXTRA_LONG_REAL ) * Pi   )
      ENDDO
      ALLOCATE( TEMP_THETA_TRANSFORM_ALF(1:GMT_THETA, (LMAX + 1) * (LMAX + 2)/2), TEMP_THETA_TRANSFORM_DALF(1:GMT_THETA, (LMAX + 1) * (LMAX + 2)/2),ALF(1:GMT_THETA, (LMAX + 1) * (LMAX + 2)/2), DALF(1:GMT_THETA, (LMAX + 1) * (LMAX + 2)/2),&
      ONE_DIV_SIN_THETA(1:GMT_THETA), U_H(1:GMT_THETA, 1:GMT_PHI, 2) )

       CALL GET_LEGENDRE_FUNCTIONS( REAL(COSTHETA_GRID, KIND = EXTRA_LONG_REAL), LMAX, LMAX, TEMP_THETA_TRANSFORM_ALF, TEMP_THETA_TRANSFORM_DALF) 
      ALF = REAL(  TEMP_THETA_TRANSFORM_ALF, KIND = EXTRA_LONG_REAL)
      DALF = REAL( TEMP_THETA_TRANSFORM_DALF, KIND = EXTRA_LONG_REAL)
      ONE_DIV_SIN_THETA(:) = 1.0_LONG_REAL / SQRT( 1.0_LONG_REAL - COSTHETA_GRID(:)**2 )
    U_H(:,:,:) = 0.0_LONG_REAL
   
    DO I_HARMONIC = 1, SIZE(EVEC_TOR)

    INDEX = HARMONICS(I_HARMONIC)%M * LMAX +  (HARMONICS(I_HARMONIC)%M * (3-HARMONICS(I_HARMONIC)%M) ) /2 + 1 + (HARMONICS(I_HARMONIC)%L - HARMONICS(I_HARMONIC)%M)

   DO I_THETA = 1, GMT_THETA
   DO I_PHI = 1, GMT_PHI
   PHI = (I_PHI-1) * 2.0_LONG_REAL * Pi / REAL(GMT_PHI, KIND = LONG_REAL)
 
    IF( HARMONICS(I_HARMONIC)%SINCOS .EQ. SINE_HARMONIC ) THEN
    PHI_DEP = SIN(  HARMONICS(I_HARMONIC)%M * PHI  )
    DERV_PHI_DEP = HARMONICS(I_HARMONIC)%M * COS(  HARMONICS(I_HARMONIC)%M * PHI )
    ELSE
    PHI_DEP = COS(  HARMONICS(I_HARMONIC)%M * PHI )
    DERV_PHI_DEP = -HARMONICS(I_HARMONIC)%M * SIN(  HARMONICS(I_HARMONIC)%M * PHI)
    ENDIF

! Toroidal flow
   U_H(I_THETA, I_PHI,1) = U_H(I_THETA, I_PHI,1) + EVEC_TOR( I_HARMONIC) * DERV_PHI_DEP * ALF(I_THETA, INDEX) * ONE_DIV_SIN_THETA(I_THETA)
   U_H(I_THETA, I_PHI,2) = U_H(I_THETA, I_PHI,2) - EVEC_TOR( I_HARMONIC) * PHI_DEP * DALF(I_THETA, INDEX)

! Poloidal flow
   U_H(I_THETA, I_PHI,1) = U_H(I_THETA, I_PHI,1) + EVEC_POL( I_HARMONIC) * PHI_DEP * DALF(I_THETA, INDEX)
   U_H(I_THETA, I_PHI,2) = U_H(I_THETA, I_PHI,2) + EVEC_POL( I_HARMONIC) * DERV_PHI_DEP * ALF(I_THETA, INDEX) * ONE_DIV_SIN_THETA(I_THETA)

   !IF( I_HARMONIC .eq. 1) PRINT*, EVEC( I_HARMONIC) , PHI_DEP , DALF(I_THETA, INDEX),DERV_PHI_DEP , ALF(I_THETA, INDEX) ,ONE_DIV_SIN_THETA(I_THETA)
   ENDDO
   ENDDO
   ENDDO

   !PRINT*, U_H
   !STOP
   OPEN(15, FILE = 'FLOW.DAT', STATUS = 'REPLACE', FORM = 'FORMATTED')

   DO I_THETA = 1, GMT_THETA
   DO I_PHI = 1, GMT_PHI
   PHI = (I_PHI-1) * 2.0_LONG_REAL * Pi / REAL(GMT_PHI, KIND = LONG_REAL)

 ANGLE_VEC =  ATAN( -U_H(I_THETA, I_PHI,2) / U_H(I_THETA, I_PHI,1) ) *180.0d0/PI
! correction as atan has principal angle -90 to +90 degrees.

    if ( U_H(I_THETA, I_PHI,1) .gt. 0.0d0) then
        if (U_H(I_THETA, I_PHI,2) .lt. 0.0d0) then
          ANGLE_VEC = ANGLE_VEC - 180.0d0
        else
          ANGLE_VEC = ANGLE_VEC + 180.0d0
        endif
      endif
  MOD_VEC = SQRT( U_H(I_THETA, I_PHI,1)**2 + U_H(I_THETA, I_PHI,2)**2 )
 WRITE(15,'(2F8.2,2F15.5)'), PHI*180.0/Pi ,90.0d0-ACOS(COSTHETA_GRID(I_THETA))*180.0/Pi, ANGLE_VEC, MOD_VEC * SCALE_FACTOR
!WRITE(15,*), PHI*180.0/Pi ,90.0d0-ACOS(COSTHETA_GRID(I_THETA))*180.0/Pi, ANGLE_VEC
  !PRINT*,  U_H(I_THETA, I_PHI,1:2)
 ENDDO
 ENDDO

  CLOSE(15)

RETURN

END  SUBROUTINE WRITE_U_GMT


SUBROUTINE WRITE_U_CENTRED( GMT_THETA, GMT_PHI, EVEC_TOR,  EVEC_POL, HARMONICS, LMAX )
! Writes the flow to a grid centred on 0 longitude 

IMPLICIT NONE
INTEGER ::  GMT_THETA, GMT_PHI,  LMAX
REAL( KIND = EXTRA_LONG_REAL) :: EVEC_TOR(1:), EVEC_POL(1:)
TYPE ( HARMONIC_STRUCTURE ) :: HARMONICS(1:)

REAL( KIND = EXTRA_LONG_REAL), ALLOCATABLE :: COSTHETA_GRID(:), ALF(:,:), DALF(:,:), ONE_DIV_SIN_THETA(:), U_H(:,:,:)
REAL( KIND = EXTRA_LONG_REAL), ALLOCATABLE :: TEMP_THETA_TRANSFORM_ALF(:,:), TEMP_THETA_TRANSFORM_DALF(:,:)
REAL( KIND = EXTRA_LONG_REAL) :: PHI, ANGLE_VEC, MOD_VEC, PHI_DEP, DERV_PHI_DEP
INTEGER :: I_THETA, I_PHI, I_HARMONIC, INDEX

! setup grids
ALLOCATE( COSTHETA_GRID(1: GMT_THETA))
DO I_THETA = 1, GMT_THETA
COSTHETA_GRID(I_THETA) = COS(  I_THETA / REAL( GMT_THETA + 1, KIND = EXTRA_LONG_REAL ) * Pi   )
ENDDO
ALLOCATE( TEMP_THETA_TRANSFORM_ALF(1:GMT_THETA, (LMAX + 1) * (LMAX + 2)/2), TEMP_THETA_TRANSFORM_DALF(1:GMT_THETA, (LMAX + 1) * (LMAX + 2)/2),ALF(1:GMT_THETA, (LMAX + 1) * (LMAX + 2)/2), DALF(1:GMT_THETA, (LMAX + 1) * (LMAX + 2)/2),&
ONE_DIV_SIN_THETA(1:GMT_THETA), U_H(1:GMT_THETA, 1:GMT_PHI, 2) )

CALL GET_LEGENDRE_FUNCTIONS( REAL(COSTHETA_GRID, KIND = EXTRA_LONG_REAL), LMAX, LMAX, TEMP_THETA_TRANSFORM_ALF, TEMP_THETA_TRANSFORM_DALF)
ALF = REAL(  TEMP_THETA_TRANSFORM_ALF, KIND = EXTRA_LONG_REAL)
DALF = REAL( TEMP_THETA_TRANSFORM_DALF, KIND = EXTRA_LONG_REAL)
ONE_DIV_SIN_THETA(:) = 1.0_LONG_REAL / SQRT( 1.0_LONG_REAL - COSTHETA_GRID(:)**2 )
U_H(:,:,:) = 0.0_LONG_REAL

DO I_HARMONIC = 1, SIZE(EVEC_TOR)

INDEX = HARMONICS(I_HARMONIC)%M * LMAX +  (HARMONICS(I_HARMONIC)%M * (3-HARMONICS(I_HARMONIC)%M) ) /2 + 1 + (HARMONICS(I_HARMONIC)%L - HARMONICS(I_HARMONIC)%M)

DO I_THETA = 1, GMT_THETA
DO I_PHI = 1, GMT_PHI
! splits up into equal segments away from the end points.
PHI = -Pi + Pi /REAL(GMT_PHI, KIND = EXTRA_LONG_REAL) + 2.0 * Pi / REAL(GMT_PHI, KIND = EXTRA_LONG_REAL) * (I_PHI-1)

IF( HARMONICS(I_HARMONIC)%SINCOS .EQ. SINE_HARMONIC ) THEN
PHI_DEP = SIN(  HARMONICS(I_HARMONIC)%M * PHI  )
DERV_PHI_DEP = HARMONICS(I_HARMONIC)%M * COS(  HARMONICS(I_HARMONIC)%M * PHI )
ELSE
PHI_DEP = COS(  HARMONICS(I_HARMONIC)%M * PHI )
DERV_PHI_DEP = -HARMONICS(I_HARMONIC)%M * SIN(  HARMONICS(I_HARMONIC)%M * PHI)
ENDIF

! Toroidal flow
U_H(I_THETA, I_PHI,1) = U_H(I_THETA, I_PHI,1) + EVEC_TOR( I_HARMONIC) * DERV_PHI_DEP * ALF(I_THETA, INDEX) * ONE_DIV_SIN_THETA(I_THETA)
U_H(I_THETA, I_PHI,2) = U_H(I_THETA, I_PHI,2) - EVEC_TOR( I_HARMONIC) * PHI_DEP * DALF(I_THETA, INDEX)

! Poloidal flow
U_H(I_THETA, I_PHI,1) = U_H(I_THETA, I_PHI,1) + EVEC_POL( I_HARMONIC) * PHI_DEP * DALF(I_THETA, INDEX)
U_H(I_THETA, I_PHI,2) = U_H(I_THETA, I_PHI,2) + EVEC_POL( I_HARMONIC) * DERV_PHI_DEP * ALF(I_THETA, INDEX) * ONE_DIV_SIN_THETA(I_THETA)

!IF( I_HARMONIC .eq. 1) PRINT*, EVEC( I_HARMONIC) , PHI_DEP , DALF(I_THETA, INDEX),DERV_PHI_DEP , ALF(I_THETA, INDEX) ,ONE_DIV_SIN_THETA(I_THETA)
ENDDO
ENDDO
ENDDO

!PRINT*, U_H
!STOP
OPEN(15, FILE = 'FLOW_VECTORS_CENTRED.DAT', STATUS = 'REPLACE', FORM = 'FORMATTED')

DO I_THETA =  GMT_THETA,1,-1
DO I_PHI = 1, GMT_PHI
PHI = -Pi + Pi /REAL(GMT_PHI, KIND = EXTRA_LONG_REAL) + 2.0 * Pi / REAL(GMT_PHI, KIND = EXTRA_LONG_REAL) * (I_PHI-1)
WRITE(15,'(2F8.2,2F15.5)'), PHI*180.0/Pi ,90.0d0-ACOS(COSTHETA_GRID(I_THETA))*180.0/Pi, U_H(I_THETA, I_PHI,1:2)
ENDDO
ENDDO

CLOSE(15)

RETURN

END  SUBROUTINE WRITE_U_CENTRED


SUBROUTINE WRITE_U_RANDOM( EVEC_TOR,  EVEC_POL, HARMONICS, LMAX )
! Writes the flow to a quasi-uniformly sampled spherical grid 

IMPLICIT NONE
INTEGER ::   LMAX
REAL( KIND = EXTRA_LONG_REAL) :: EVEC_TOR(1:), EVEC_POL(1:)
TYPE ( HARMONIC_STRUCTURE ) :: HARMONICS(1:)

REAL( KIND = EXTRA_LONG_REAL), ALLOCATABLE :: COSTHETA_GRID(:), ALF(:,:), DALF(:,:), U_H(:)
REAL( KIND = EXTRA_LONG_REAL), ALLOCATABLE :: TEMP_THETA_TRANSFORM_ALF(:,:), TEMP_THETA_TRANSFORM_DALF(:,:)
REAL( KIND = EXTRA_LONG_REAL) :: PHI, PHI_DEP, DERV_PHI_DEP,  ONE_DIV_SIN_THETA, RANDOM_NUMBERS( 1:2 ), THETA
INTEGER :: I_THETA, I_PHI, I_HARMONIC, INDEX, i, I_LOC
INTEGER, ALLOCATABLE :: SEED(:)

! Generate LAT/LONG grid
CALL RANDOM_SEED(SIZE = i)
ALLOCATE( SEED(1:i) )
SEED(:) = 1
CALL RANDOM_SEED(PUT = SEED)

ALLOCATE( COSTHETA_GRID(1)) 
OPEN(15, FILE = 'FLOW_VECTORS_RANDOM.DAT', STATUS = 'REPLACE', FORM = 'FORMATTED')

ALLOCATE( TEMP_THETA_TRANSFORM_ALF(1, (LMAX + 1) * (LMAX + 2)/2), TEMP_THETA_TRANSFORM_DALF(1, (LMAX + 1) * (LMAX + 2)/2),ALF(1, (LMAX + 1) * (LMAX + 2)/2), DALF(1, (LMAX + 1) * (LMAX + 2)/2),  U_H(2) )

DO I_LOC = 1, NUMBER_RANDOM_START_PTS
CALL RANDOM_NUMBER( RANDOM_NUMBERS(1:2) )
!PRINT*, RANDOM_NUMBERS
PHI = RANDOM_NUMBERS(1) * 2.0_8 * Pi
THETA = ASIN( SQRT(1.0_8 - (2.0_8 * RANDOM_NUMBERS(2) - 1.0_8)**2) )
IF((2.0_8 * RANDOM_NUMBERS(2) - 1.0_8) < 0.0_8 ) THETA = Pi - THETA
COSTHETA_GRID(1) = COS(THETA)
!PRINT*, THETA, PHI



CALL GET_LEGENDRE_FUNCTIONS( REAL(COSTHETA_GRID, KIND = EXTRA_LONG_REAL), LMAX, LMAX, TEMP_THETA_TRANSFORM_ALF, TEMP_THETA_TRANSFORM_DALF)
ALF = REAL(  TEMP_THETA_TRANSFORM_ALF, KIND = EXTRA_LONG_REAL)
DALF = REAL( TEMP_THETA_TRANSFORM_DALF, KIND = EXTRA_LONG_REAL)

ONE_DIV_SIN_THETA = 1.0_LONG_REAL / SQRT( 1.0_LONG_REAL - COSTHETA_GRID(1)**2 )
U_H(:) = 0.0_LONG_REAL

DO I_HARMONIC = 1, SIZE(EVEC_TOR)

INDEX = HARMONICS(I_HARMONIC)%M * LMAX +  (HARMONICS(I_HARMONIC)%M * (3-HARMONICS(I_HARMONIC)%M) ) /2 + 1 + (HARMONICS(I_HARMONIC)%L - HARMONICS(I_HARMONIC)%M)

IF( HARMONICS(I_HARMONIC)%SINCOS .EQ. SINE_HARMONIC ) THEN
PHI_DEP = SIN(  HARMONICS(I_HARMONIC)%M * PHI  )
DERV_PHI_DEP = HARMONICS(I_HARMONIC)%M * COS(  HARMONICS(I_HARMONIC)%M * PHI )
ELSE
PHI_DEP = COS(  HARMONICS(I_HARMONIC)%M * PHI )
DERV_PHI_DEP = -HARMONICS(I_HARMONIC)%M * SIN(  HARMONICS(I_HARMONIC)%M * PHI)
ENDIF

! Toroidal flow
U_H(1) = U_H(1) + EVEC_TOR( I_HARMONIC) * DERV_PHI_DEP * ALF(1, INDEX) * ONE_DIV_SIN_THETA
U_H(2) = U_H(2) - EVEC_TOR( I_HARMONIC) * PHI_DEP * DALF(1, INDEX)

! Poloidal flow
U_H(1) = U_H(1) + EVEC_POL( I_HARMONIC) * PHI_DEP * DALF(1, INDEX)
U_H(2) = U_H(2) + EVEC_POL( I_HARMONIC) * DERV_PHI_DEP * ALF(1,INDEX) * ONE_DIV_SIN_THETA

!IF( I_HARMONIC .eq. 1) PRINT*, EVEC( I_HARMONIC) , PHI_DEP , DALF(I_THETA, INDEX),DERV_PHI_DEP , ALF(I_THETA, INDEX) ,ONE_DIV_SIN_THETA(I_THETA)
ENDDO

WRITE(15,'(2F8.2,2F15.5)'), PHI*180.0/Pi ,90.0 - THETA*180.0/Pi, U_H(1:2)

ENDDO

CLOSE(15)

RETURN

END  SUBROUTINE WRITE_U_RANDOM



SUBROUTINE CALC_U_GRID( THETA_GRID_SIZE, PHI_GRID_SIZE, COSTHETA_GRID, PHI_GRID, EVEC_TOR,  EVEC_POL, HARMONICS, LMAX, USQ )
! Computes u^2 on a grid

IMPLICIT NONE
INTEGER ::  THETA_GRID_SIZE, PHI_GRID_SIZE,  LMAX
REAL( KIND = EXTRA_LONG_REAL) :: EVEC_TOR(1:), EVEC_POL(1:), USQ(:,:), PHI_GRID(PHI_GRID_SIZE), COSTHETA_GRID(1:THETA_GRID_SIZE)
TYPE ( HARMONIC_STRUCTURE ) :: HARMONICS(1:)

REAL( KIND = EXTRA_LONG_REAL), ALLOCATABLE :: ALF(:,:), DALF(:,:), ONE_DIV_SIN_THETA(:), U_H(:,:,:)
REAL( KIND = EXTRA_LONG_REAL), ALLOCATABLE :: TEMP_THETA_TRANSFORM_ALF(:,:), TEMP_THETA_TRANSFORM_DALF(:,:)
REAL( KIND = EXTRA_LONG_REAL) :: PHI, ANGLE_VEC, MOD_VEC, PHI_DEP, DERV_PHI_DEP
INTEGER :: I_THETA, I_PHI, I_HARMONIC, INDEX

!PRINT*, PHI_GRID_SIZE, THETA_GRID_SIZE

! setup grids

ALLOCATE( TEMP_THETA_TRANSFORM_ALF(1:THETA_GRID_SIZE, (LMAX + 1) * (LMAX + 2)/2), TEMP_THETA_TRANSFORM_DALF(1:THETA_GRID_SIZE, (LMAX + 1) * (LMAX + 2)/2),ALF(1:THETA_GRID_SIZE, (LMAX + 1) * (LMAX + 2)/2), DALF(1:THETA_GRID_SIZE, (LMAX + 1) * (LMAX + 2)/2),&
ONE_DIV_SIN_THETA(1:THETA_GRID_SIZE), U_H(1:THETA_GRID_SIZE, 1:PHI_GRID_SIZE, 2) )

CALL GET_LEGENDRE_FUNCTIONS( REAL(COSTHETA_GRID, KIND = EXTRA_LONG_REAL), LMAX, LMAX, TEMP_THETA_TRANSFORM_ALF, TEMP_THETA_TRANSFORM_DALF)
ALF = REAL(  TEMP_THETA_TRANSFORM_ALF, KIND = EXTRA_LONG_REAL)
DALF = REAL( TEMP_THETA_TRANSFORM_DALF, KIND = EXTRA_LONG_REAL)
ONE_DIV_SIN_THETA(:) = 1.0_LONG_REAL / SQRT( 1.0_LONG_REAL - COSTHETA_GRID(:)**2 )
U_H(:,:,:) = 0.0_LONG_REAL

DO I_HARMONIC = 1, SIZE(EVEC_TOR)

INDEX = HARMONICS(I_HARMONIC)%M * LMAX +  (HARMONICS(I_HARMONIC)%M * (3-HARMONICS(I_HARMONIC)%M) ) /2 + 1 + (HARMONICS(I_HARMONIC)%L - HARMONICS(I_HARMONIC)%M)

DO I_THETA = 1, THETA_GRID_SIZE
DO I_PHI = 1, PHI_GRID_SIZE
PHI = (I_PHI-1) * 2.0_LONG_REAL * Pi / REAL(PHI_GRID_SIZE, KIND = EXTRA_LONG_REAL)

IF( HARMONICS(I_HARMONIC)%SINCOS .EQ. SINE_HARMONIC ) THEN
PHI_DEP = SIN(  HARMONICS(I_HARMONIC)%M * PHI  )
DERV_PHI_DEP = HARMONICS(I_HARMONIC)%M * COS(  HARMONICS(I_HARMONIC)%M * PHI )
ELSE
PHI_DEP = COS(  HARMONICS(I_HARMONIC)%M * PHI )
DERV_PHI_DEP = -HARMONICS(I_HARMONIC)%M * SIN(  HARMONICS(I_HARMONIC)%M * PHI)
ENDIF

! Toroidal flow
U_H(I_THETA, I_PHI,1) = U_H(I_THETA, I_PHI,1) + EVEC_TOR( I_HARMONIC) * DERV_PHI_DEP * ALF(I_THETA, INDEX) * ONE_DIV_SIN_THETA(I_THETA)
U_H(I_THETA, I_PHI,2) = U_H(I_THETA, I_PHI,2) - EVEC_TOR( I_HARMONIC) * PHI_DEP * DALF(I_THETA, INDEX)

! Poloidal flow
U_H(I_THETA, I_PHI,1) = U_H(I_THETA, I_PHI,1) + EVEC_POL( I_HARMONIC) * PHI_DEP * DALF(I_THETA, INDEX)
U_H(I_THETA, I_PHI,2) = U_H(I_THETA, I_PHI,2) + EVEC_POL( I_HARMONIC) * DERV_PHI_DEP * ALF(I_THETA, INDEX) * ONE_DIV_SIN_THETA(I_THETA)

!IF( I_HARMONIC .eq. 1) PRINT*, EVEC( I_HARMONIC) , PHI_DEP , DALF(I_THETA, INDEX),DERV_PHI_DEP , ALF(I_THETA, INDEX) ,ONE_DIV_SIN_THETA(I_THETA)
ENDDO
ENDDO
ENDDO

DO I_THETA = 1, THETA_GRID_SIZE
DO I_PHI = 1, PHI_GRID_SIZE
USQ(I_THETA, I_PHI) = U_H(I_THETA, I_PHI,1)**2 + U_H(I_THETA, I_PHI,2)**2
ENDDO
ENDDO


RETURN

END  SUBROUTINE CALC_U_GRID


SUBROUTINE WRITE_TOR_STREAM_FN( N_THETA, N_PHI, EVEC_TOR,  HARMONICS, LMAX )
! Writes the stream function of the toroidal flow to a grid centred on 0 longitude

IMPLICIT NONE
INTEGER ::  N_THETA, N_PHI,  LMAX
REAL( KIND = EXTRA_LONG_REAL) :: EVEC_TOR(1:)
TYPE ( HARMONIC_STRUCTURE ) :: HARMONICS(1:)

REAL( KIND = EXTRA_LONG_REAL), ALLOCATABLE :: COSTHETA_GRID(:), ALF(:,:), DALF(:,:), ONE_DIV_SIN_THETA(:), STREAMFN(:,:)
REAL( KIND = EXTRA_LONG_REAL), ALLOCATABLE :: TEMP_THETA_TRANSFORM_ALF(:,:), TEMP_THETA_TRANSFORM_DALF(:,:)
REAL( KIND = EXTRA_LONG_REAL) :: PHI, ANGLE_VEC, MOD_VEC, PHI_DEP, DERV_PHI_DEP
INTEGER :: I_THETA, I_PHI, I_HARMONIC, INDEX

! setup grids
ALLOCATE( COSTHETA_GRID(1: N_THETA))
DO I_THETA = 1, N_THETA
COSTHETA_GRID(I_THETA) = COS(  I_THETA / REAL( N_THETA + 1, KIND = EXTRA_LONG_REAL ) * Pi   )
ENDDO
ALLOCATE( TEMP_THETA_TRANSFORM_ALF(1:N_THETA, (LMAX + 1) * (LMAX + 2)/2), TEMP_THETA_TRANSFORM_DALF(1:N_THETA, (LMAX + 1) * (LMAX + 2)/2),ALF(1:N_THETA, (LMAX + 1) * (LMAX + 2)/2), DALF(1:N_THETA, (LMAX + 1) * (LMAX + 2)/2),&
ONE_DIV_SIN_THETA(1:N_THETA), STREAMFN(1:N_THETA, 1:N_PHI) )

CALL GET_LEGENDRE_FUNCTIONS( REAL(COSTHETA_GRID, KIND = EXTRA_LONG_REAL), LMAX, LMAX, TEMP_THETA_TRANSFORM_ALF, TEMP_THETA_TRANSFORM_DALF)
ALF = REAL(  TEMP_THETA_TRANSFORM_ALF, KIND = EXTRA_LONG_REAL)
DALF = REAL( TEMP_THETA_TRANSFORM_DALF, KIND = EXTRA_LONG_REAL)
ONE_DIV_SIN_THETA(:) = 1.0_LONG_REAL / SQRT( 1.0_LONG_REAL - COSTHETA_GRID(:)**2 )
STREAMFN(:,:) = 0.0_LONG_REAL

DO I_HARMONIC = 1, SIZE(EVEC_TOR)

INDEX = HARMONICS(I_HARMONIC)%M * LMAX +  (HARMONICS(I_HARMONIC)%M * (3-HARMONICS(I_HARMONIC)%M) ) /2 + 1 + (HARMONICS(I_HARMONIC)%L - HARMONICS(I_HARMONIC)%M)

DO I_THETA = 1, N_THETA
DO I_PHI = 1, N_PHI
! splits up into equal segments away from the end points.
PHI = -Pi + Pi /REAL(N_PHI, KIND = EXTRA_LONG_REAL) + 2.0 * Pi / REAL(N_PHI, KIND = EXTRA_LONG_REAL) * (I_PHI-1)

IF( HARMONICS(I_HARMONIC)%SINCOS .EQ. SINE_HARMONIC ) THEN
PHI_DEP = SIN(  HARMONICS(I_HARMONIC)%M * PHI  )
DERV_PHI_DEP = HARMONICS(I_HARMONIC)%M * COS(  HARMONICS(I_HARMONIC)%M * PHI )
ELSE
PHI_DEP = COS(  HARMONICS(I_HARMONIC)%M * PHI )
DERV_PHI_DEP = -HARMONICS(I_HARMONIC)%M * SIN(  HARMONICS(I_HARMONIC)%M * PHI)
ENDIF

! Toroidal flow
STREAMFN(I_THETA, I_PHI) = STREAMFN(I_THETA, I_PHI) + EVEC_TOR( I_HARMONIC) * PHI_DEP * ALF(I_THETA, INDEX)

ENDDO
ENDDO
ENDDO

!PRINT*, U_H
!STOP
OPEN(15, FILE = 'TOROIDAL_STREAMFN_CENTRED.DAT', STATUS = 'REPLACE', FORM = 'FORMATTED')

DO I_PHI = 1, N_PHI
DO I_THETA =  N_THETA,1,-1
PHI = -Pi + Pi /REAL(N_PHI, KIND = EXTRA_LONG_REAL) + 2.0 * Pi / REAL(N_PHI, KIND = EXTRA_LONG_REAL) * (I_PHI-1)
WRITE(15,'(2F8.2,2F15.5)'), PHI*180.0/Pi ,90.0d0-ACOS(COSTHETA_GRID(I_THETA))*180.0/Pi, STREAMFN(I_THETA, I_PHI)
ENDDO
ENDDO

CLOSE(15)

RETURN

END  SUBROUTINE WRITE_TOR_STREAM_FN



  SUBROUTINE WRITE_F_DOT_GMT (GAUSS_DOT, GAUSS, LMAX_B, LMAX_SV, HARMONICS )
! Writes both F and Fdot to disk in a format that GMT can read.
! Note that both GAUSS and GAUSS-DOT are Gauss-type coefficients, both in units of nT/yr
! CS -> quantity on the CMB
! ES -> quantity at the Earth's surface
! F = total intensity
! D = magnetic declination

!Also write in a centred grid for Python
  IMPLICIT NONE

  REAL( KIND = EXTRA_LONG_REAL) :: GAUSS_DOT(:), GAUSS(:)
  TYPE ( HARMONIC_STRUCTURE ) :: HARMONICS(1:)
  INTEGER :: LMAX_SV, LMAX_B

      REAL( KIND = EXTRA_LONG_REAL), ALLOCATABLE :: COSTHETA_GRID(:), ALF(:,:), DALF(:,:), ONE_DIV_SIN_THETA(:)
      REAL( KIND = EXTRA_LONG_REAL), ALLOCATABLE :: TEMP_THETA_TRANSFORM_ALF(:,:), TEMP_THETA_TRANSFORM_DALF(:,:)
      REAL( KIND = EXTRA_LONG_REAL) :: PHI,  PHI_DEP, DERV_PHI_DEP, B_DOT_LOCATION(3), B_LOCATION(3)
      REAL( KIND = 8) :: F_LOC
      INTEGER :: I_THETA, I_PHI, I_HARMONIC, INDEX_PLM, I


! setup grids
      ALLOCATE( COSTHETA_GRID(1: NTHETA_GRID_CONTOUR_GMT))
      DO I_THETA = 1, NTHETA_GRID_CONTOUR_GMT
       COSTHETA_GRID(I_THETA) = COS(  I_THETA / REAL( NTHETA_GRID_CONTOUR_GMT + 1, KIND = EXTRA_LONG_REAL ) * Pi   )
      ENDDO

      ALLOCATE( TEMP_THETA_TRANSFORM_ALF(1: NTHETA_GRID_CONTOUR_GMT, (LMAX_SV + 1) * (LMAX_SV + 2)/2), TEMP_THETA_TRANSFORM_DALF(1: NTHETA_GRID_CONTOUR_GMT, (LMAX_SV + 1) * (LMAX_SV + 2)/2),ALF(1: NTHETA_GRID_CONTOUR_GMT, (LMAX_SV + 1) * (LMAX_SV + 2)/2), DALF(1: NTHETA_GRID_CONTOUR_GMT, (LMAX_SV + 1) * (LMAX_SV + 2)/2),  ONE_DIV_SIN_THETA(1: NTHETA_GRID_CONTOUR_GMT) )
      
       CALL GET_LEGENDRE_FUNCTIONS( REAL(COSTHETA_GRID, KIND = EXTRA_LONG_REAL), LMAX_SV, LMAX_SV, TEMP_THETA_TRANSFORM_ALF, TEMP_THETA_TRANSFORM_DALF) 
      ALF = REAL(  TEMP_THETA_TRANSFORM_ALF, KIND = EXTRA_LONG_REAL)
      DALF = REAL( TEMP_THETA_TRANSFORM_DALF, KIND = EXTRA_LONG_REAL)
      ONE_DIV_SIN_THETA(:) = 1.0_EXTRA_LONG_REAL / SQRT( 1.0_EXTRA_LONG_REAL - COSTHETA_GRID(:)**2 )

          
    OPEN(16, FILE = 'D_DOT_ES.DAT', STATUS = 'REPLACE', FORM = 'FORMATTED')
    OPEN(17, FILE = 'D_ES.DAT', STATUS = 'REPLACE', FORM = 'FORMATTED')
    OPEN(18, FILE = 'F_DOT_ES.DAT', STATUS = 'REPLACE', FORM = 'FORMATTED')
    OPEN(19, FILE = 'F_ES.DAT', STATUS = 'REPLACE', FORM = 'FORMATTED')

    DO I_PHI = 0, NPHI_GRID_CONTOUR_GMT-1
    DO I_THETA = 1, NTHETA_GRID_CONTOUR_GMT
    
    PHI =  I_PHI * 2.0_EXTRA_LONG_REAL * Pi / REAL(NPHI_GRID_CONTOUR_GMT, KIND = EXTRA_LONG_REAL)
    B_DOT_LOCATION(1:3) = 0.0_EXTRA_LONG_REAL
    B_LOCATION(1:3) = 0.0_EXTRA_LONG_REAL

    DO I = 1, LMAX_SV * (LMAX_SV + 2)
! evaluate B and B_dot at Earth surface
    IF( HARMONICS(I)%SINCOS .EQ. SINE_HARMONIC ) THEN
    PHI_DEP = SIN(  HARMONICS(I)%M * PHI )
    DERV_PHI_DEP = HARMONICS(I)%M * COS(  HARMONICS(I)%M * PHI )
    ELSE
    PHI_DEP = COS(  HARMONICS(I)%M * PHI )
    DERV_PHI_DEP = -HARMONICS(I)%M * SIN(  HARMONICS(I)%M * PHI)
    ENDIF

    INDEX_PLM = HARMONICS(I)%M * LMAX_SV +  (HARMONICS(I)%M * (3-HARMONICS(I)%M) ) /2 + 1 + (HARMONICS(I)%L - HARMONICS(I)%M)
    B_DOT_LOCATION(1) = B_DOT_LOCATION(1) + GAUSS_DOT(I) * ALF(I_THETA, INDEX_PLM) * PHI_DEP  * REAL(HARMONICS(I)%L + 1, KIND = EXTRA_LONG_REAL)
    B_DOT_LOCATION(2) = B_DOT_LOCATION(2) - GAUSS_DOT(I) * DALF(I_THETA, INDEX_PLM) * PHI_DEP  
    B_DOT_LOCATION(3) = B_DOT_LOCATION(3) - GAUSS_DOT(I) * ALF(I_THETA, INDEX_PLM) * DERV_PHI_DEP * ONE_DIV_SIN_THETA(I_THETA)  

    IF( HARMONICS(I)%L .LE. LMAX_B ) THEN !SV goes to higher L than B[obs], so exclude if index goes higher than required.
    B_LOCATION(1) = B_LOCATION(1) + GAUSS(I) *  ALF(I_THETA, INDEX_PLM) * PHI_DEP * REAL(HARMONICS(I)%L + 1, KIND = EXTRA_LONG_REAL)   
    B_LOCATION(2) = B_LOCATION(2) - GAUSS(I) * DALF(I_THETA, INDEX_PLM) * PHI_DEP  
    B_LOCATION(3) = B_LOCATION(3) - GAUSS(I) * ALF(I_THETA, INDEX_PLM) * DERV_PHI_DEP * ONE_DIV_SIN_THETA(I_THETA) 
    ENDIF

    ENDDO
! for declination:
    WRITE(16,'(2F8.2,ES15.5)'), PHI*180.0/Pi ,90.0d0-ACOS(COSTHETA_GRID(I_THETA))*180.0/Pi, (B_DOT_LOCATION(2) * B_LOCATION(3) - B_DOT_LOCATION(3) * B_LOCATION(2)) / ((B_LOCATION(2) * B_LOCATION(2)) + (B_LOCATION(3) * B_LOCATION(3))) 
    WRITE(17,'(2F8.2,ES15.5)'), PHI*180.0/Pi ,90.0d0-ACOS(COSTHETA_GRID(I_THETA))*180.0/Pi,  atan2(B_LOCATION(3),(-B_LOCATION(2))) 
! for intensity:
    F_LOC = SQRT( SUM(B_LOCATION**2) )
    WRITE(18,'(2F8.2,ES15.5)'), PHI*180.0/Pi, 90.0d0-ACOS(COSTHETA_GRID(I_THETA))*180.0/Pi, SUM( B_DOT_LOCATION(:) * B_LOCATION(:) ) / F_LOC 
    WRITE(19,'(2F8.2,ES15.5)'), PHI*180.0/Pi, 90.0d0-ACOS(COSTHETA_GRID(I_THETA))*180.0/Pi, F_LOC 

    !PRINT*, SUM( B_DOT_LOCATION(:)  * B_LOCATION(:) ) , SUM( B_DOT_LOCATION(:)  * B_LOCATION(:) ) / SQRT( SUM(B_LOCATION**2 ) )
    ENDDO
    ENDDO

!
    CLOSE(16)
    CLOSE(17)
    CLOSE(18)
    CLOSE(19)


OPEN(16, FILE = 'D_DOT_ES_CENTRED.DAT', STATUS = 'REPLACE', FORM = 'FORMATTED')
OPEN(17, FILE = 'D_ES_CENTRED.DAT', STATUS = 'REPLACE', FORM = 'FORMATTED')
OPEN(18, FILE = 'F_DOT_ES_CENTRED.DAT', STATUS = 'REPLACE', FORM = 'FORMATTED')
OPEN(19, FILE = 'F_ES_CENTRED.DAT', STATUS = 'REPLACE', FORM = 'FORMATTED')

DO I_PHI = 1, NPHI_GRID_CONTOUR_GMT
DO I_THETA = 1, NTHETA_GRID_CONTOUR_GMT

PHI = -Pi + Pi /REAL(NPHI_GRID_CONTOUR_GMT, KIND = EXTRA_LONG_REAL) + 2.0 * Pi / REAL(NPHI_GRID_CONTOUR_GMT, KIND = EXTRA_LONG_REAL) * (I_PHI-1)
B_DOT_LOCATION(1:3) = 0.0_EXTRA_LONG_REAL
B_LOCATION(1:3) = 0.0_EXTRA_LONG_REAL

DO I = 1, LMAX_SV * (LMAX_SV + 2)
! evaluate B and B_dot at Earth surface
IF( HARMONICS(I)%SINCOS .EQ. SINE_HARMONIC ) THEN
PHI_DEP = SIN(  HARMONICS(I)%M * PHI )
DERV_PHI_DEP = HARMONICS(I)%M * COS(  HARMONICS(I)%M * PHI )
ELSE
PHI_DEP = COS(  HARMONICS(I)%M * PHI )
DERV_PHI_DEP = -HARMONICS(I)%M * SIN(  HARMONICS(I)%M * PHI)
ENDIF

INDEX_PLM = HARMONICS(I)%M * LMAX_SV +  (HARMONICS(I)%M * (3-HARMONICS(I)%M) ) /2 + 1 + (HARMONICS(I)%L - HARMONICS(I)%M)
B_DOT_LOCATION(1) = B_DOT_LOCATION(1) + GAUSS_DOT(I) * ALF(I_THETA, INDEX_PLM) * PHI_DEP  * REAL(HARMONICS(I)%L + 1, KIND = EXTRA_LONG_REAL)
B_DOT_LOCATION(2) = B_DOT_LOCATION(2) - GAUSS_DOT(I) * DALF(I_THETA, INDEX_PLM) * PHI_DEP
B_DOT_LOCATION(3) = B_DOT_LOCATION(3) - GAUSS_DOT(I) * ALF(I_THETA, INDEX_PLM) * DERV_PHI_DEP * ONE_DIV_SIN_THETA(I_THETA)

IF( HARMONICS(I)%L .LE. LMAX_B ) THEN !SV goes to higher L than B[obs], so exclude if index goes higher than required.
B_LOCATION(1) = B_LOCATION(1) + GAUSS(I) *  ALF(I_THETA, INDEX_PLM) * PHI_DEP * REAL(HARMONICS(I)%L + 1, KIND = EXTRA_LONG_REAL)
B_LOCATION(2) = B_LOCATION(2) - GAUSS(I) * DALF(I_THETA, INDEX_PLM) * PHI_DEP
B_LOCATION(3) = B_LOCATION(3) - GAUSS(I) * ALF(I_THETA, INDEX_PLM) * DERV_PHI_DEP * ONE_DIV_SIN_THETA(I_THETA)
ENDIF

ENDDO
WRITE(16,'(2F8.2,ES15.5)'), PHI*180.0/Pi ,90.0d0-ACOS(COSTHETA_GRID(I_THETA))*180.0/Pi,(B_DOT_LOCATION(2) * B_LOCATION(3) - B_DOT_LOCATION(3) * B_LOCATION(2)) / ((B_LOCATION(2) * B_LOCATION(2)) + (B_LOCATION(3) * B_LOCATION(3))) 
WRITE(17,'(2F8.2,ES15.5)'), PHI*180.0/Pi ,90.0d0-ACOS(COSTHETA_GRID(I_THETA))*180.0/Pi, atan2(B_LOCATION(3),-B_LOCATION(2))
WRITE(18,'(2F8.2,ES15.5)'), PHI*180.0/Pi,90.0d0-ACOS(COSTHETA_GRID(I_THETA))*180.0/Pi, SUM( B_DOT_LOCATION(:) * B_LOCATION(:) ) / SQRT( SUM( B_LOCATION(:)**2) )
WRITE(19,'(2F8.2,ES15.5)'), PHI*180.0/Pi,90.0d0-ACOS(COSTHETA_GRID(I_THETA))*180.0/Pi, SQRT( SUM( B_LOCATION(:)**2) )

!PRINT*, SUM( B_DOT_LOCATION(:)  * B_LOCATION(:) ) , SUM( B_DOT_LOCATION(:)  * B_LOCATION(:) ) / SQRT( SUM(B_LOCATION**2 ) )
ENDDO
ENDDO

!
CLOSE(16)
CLOSE(17)
CLOSE(18)
CLOSE(19)

OPEN(16, FILE = 'D_DOT_CS_CENTRED.DAT', STATUS = 'REPLACE', FORM = 'FORMATTED')
OPEN(17, FILE = 'D_CS_CENTRED.DAT', STATUS = 'REPLACE', FORM = 'FORMATTED')
OPEN(18, FILE = 'F_DOT_CS_CENTRED.DAT', STATUS = 'REPLACE', FORM = 'FORMATTED')
OPEN(19, FILE = 'F_CS_CENTRED.DAT', STATUS = 'REPLACE', FORM = 'FORMATTED')

DO I_PHI = 1, NPHI_GRID_CONTOUR_GMT
DO I_THETA = 1, NTHETA_GRID_CONTOUR_GMT

PHI = -Pi + Pi /REAL(NPHI_GRID_CONTOUR_GMT, KIND = EXTRA_LONG_REAL) + 2.0 * Pi / REAL(NPHI_GRID_CONTOUR_GMT, KIND = EXTRA_LONG_REAL) * (I_PHI-1)
B_DOT_LOCATION(1:3) = 0.0_EXTRA_LONG_REAL
B_LOCATION(1:3) = 0.0_EXTRA_LONG_REAL

DO I = 1, LMAX_SV * (LMAX_SV + 2)
! evaluate B and B_dot at Earth surface
IF( HARMONICS(I)%SINCOS .EQ. SINE_HARMONIC ) THEN
PHI_DEP = SIN(  HARMONICS(I)%M * PHI )
DERV_PHI_DEP = HARMONICS(I)%M * COS(  HARMONICS(I)%M * PHI )
ELSE
PHI_DEP = COS(  HARMONICS(I)%M * PHI )
DERV_PHI_DEP = -HARMONICS(I)%M * SIN(  HARMONICS(I)%M * PHI)
ENDIF

INDEX_PLM = HARMONICS(I)%M * LMAX_SV +  (HARMONICS(I)%M * (3-HARMONICS(I)%M) ) /2 + 1 + (HARMONICS(I)%L - HARMONICS(I)%M)
B_DOT_LOCATION(1) = B_DOT_LOCATION(1) + GAUSS_DOT(I) * ALF(I_THETA, INDEX_PLM) * PHI_DEP  * REAL(HARMONICS(I)%L + 1, KIND = EXTRA_LONG_REAL) * (ES_RADIUS / CMB_RADIUS)**(HARMONICS(I)%L+2)
B_DOT_LOCATION(2) = B_DOT_LOCATION(2) - GAUSS_DOT(I) * DALF(I_THETA, INDEX_PLM) * PHI_DEP * (ES_RADIUS / CMB_RADIUS)**(HARMONICS(I)%L+1)
B_DOT_LOCATION(3) = B_DOT_LOCATION(3) - GAUSS_DOT(I) * ALF(I_THETA, INDEX_PLM) * DERV_PHI_DEP * ONE_DIV_SIN_THETA(I_THETA) * (ES_RADIUS / CMB_RADIUS)**(HARMONICS(I)%L+1)

IF( HARMONICS(I)%L .LE. LMAX_B ) THEN !SV goes to higher L than B[obs], so exclude if index goes higher than required.
B_LOCATION(1) = B_LOCATION(1) + GAUSS(I) *  ALF(I_THETA, INDEX_PLM) * PHI_DEP * REAL(HARMONICS(I)%L + 1, KIND = EXTRA_LONG_REAL)* (ES_RADIUS / CMB_RADIUS)**(HARMONICS(I)%L+2)
B_LOCATION(2) = B_LOCATION(2) - GAUSS(I) * DALF(I_THETA, INDEX_PLM) * PHI_DEP* (ES_RADIUS / CMB_RADIUS)**(HARMONICS(I)%L+1)
B_LOCATION(3) = B_LOCATION(3) - GAUSS(I) * ALF(I_THETA, INDEX_PLM) * DERV_PHI_DEP * ONE_DIV_SIN_THETA(I_THETA)* (ES_RADIUS / CMB_RADIUS)**(HARMONICS(I)%L+1)
ENDIF

ENDDO
WRITE(16,'(2F8.2,ES15.5)'), PHI*180.0/Pi ,90.0d0-ACOS(COSTHETA_GRID(I_THETA))*180.0/Pi, (B_DOT_LOCATION(2) * B_LOCATION(3) - B_DOT_LOCATION(3) * B_LOCATION(2)) / ((B_LOCATION(2) * B_LOCATION(2)) + (B_LOCATION(3) * B_LOCATION(3)))
WRITE(17,'(2F8.2,ES15.5)'), PHI*180.0/Pi ,90.0d0-ACOS(COSTHETA_GRID(I_THETA))*180.0/Pi, atan2( B_LOCATION(3),-B_LOCATION(2)) 
WRITE(18,'(2F8.2,ES15.5)'), PHI*180.0/Pi,90.0d0-ACOS(COSTHETA_GRID(I_THETA))*180.0/Pi, SUM( B_DOT_LOCATION(:) * B_LOCATION(:) ) / SQRT( SUM( B_LOCATION(:)**2) )
WRITE(19,'(2F8.2,ES15.5)'), PHI*180.0/Pi,90.0d0-ACOS(COSTHETA_GRID(I_THETA))*180.0/Pi, SQRT( SUM( B_LOCATION(:)**2) )
!PRINT*, SUM( B_DOT_LOCATION(:)  * B_LOCATION(:) ) , SUM( B_DOT_LOCATION(:)  * B_LOCATION(:) ) / SQRT( SUM(B_LOCATION**2 ) )
ENDDO
ENDDO

!
CLOSE(16)
CLOSE(17)
CLOSE(18)
CLOSE(19)



    RETURN
    END SUBROUTINE WRITE_F_DOT_GMT


SUBROUTINE WRITE_BR_BR_DOT (GAUSS_DOT, GAUSS, LMAX_B, LMAX_SV, HARMONICS )
! Writes both BR and BR_DOT to disk in either lat/long or centred format.
! Note that both GAUSS and GAUSS-DOT are Gauss-type coefficients, both in units of nT/yr

IMPLICIT NONE

REAL( KIND = EXTRA_LONG_REAL) :: GAUSS_DOT(:), GAUSS(:)
TYPE ( HARMONIC_STRUCTURE ) :: HARMONICS(1:)
INTEGER :: LMAX_SV, LMAX_B

REAL( KIND = EXTRA_LONG_REAL), ALLOCATABLE :: COSTHETA_GRID(:), ALF(:,:), DALF(:,:), ONE_DIV_SIN_THETA(:)
REAL( KIND = EXTRA_LONG_REAL), ALLOCATABLE :: TEMP_THETA_TRANSFORM_ALF(:,:), TEMP_THETA_TRANSFORM_DALF(:,:)
REAL( KIND = EXTRA_LONG_REAL) :: PHI,  PHI_DEP, DERV_PHI_DEP, B_DOT_LOCATION(3), B_LOCATION(3), BR_CS
INTEGER :: I_THETA, I_PHI, I_HARMONIC, INDEX_PLM, I


! setup grids
ALLOCATE( COSTHETA_GRID(1: NTHETA_GRID_CONTOUR_GMT))
DO I_THETA = 1, NTHETA_GRID_CONTOUR_GMT
COSTHETA_GRID(I_THETA) = COS(  I_THETA / REAL( NTHETA_GRID_CONTOUR_GMT + 1, KIND = EXTRA_LONG_REAL ) * Pi   )
ENDDO

ALLOCATE( TEMP_THETA_TRANSFORM_ALF(1: NTHETA_GRID_CONTOUR_GMT, (LMAX_SV + 1) * (LMAX_SV + 2)/2), TEMP_THETA_TRANSFORM_DALF(1: NTHETA_GRID_CONTOUR_GMT, (LMAX_SV + 1) * (LMAX_SV + 2)/2),ALF(1: NTHETA_GRID_CONTOUR_GMT, (LMAX_SV + 1) * (LMAX_SV + 2)/2), DALF(1: NTHETA_GRID_CONTOUR_GMT, (LMAX_SV + 1) * (LMAX_SV + 2)/2),  ONE_DIV_SIN_THETA(1: NTHETA_GRID_CONTOUR_GMT) )

CALL GET_LEGENDRE_FUNCTIONS( REAL(COSTHETA_GRID, KIND = EXTRA_LONG_REAL), LMAX_SV, LMAX_SV, TEMP_THETA_TRANSFORM_ALF, TEMP_THETA_TRANSFORM_DALF)
ALF = REAL(  TEMP_THETA_TRANSFORM_ALF, KIND = EXTRA_LONG_REAL)
DALF = REAL( TEMP_THETA_TRANSFORM_DALF, KIND = EXTRA_LONG_REAL)
ONE_DIV_SIN_THETA(:) = 1.0_EXTRA_LONG_REAL / SQRT( 1.0_EXTRA_LONG_REAL - COSTHETA_GRID(:)**2 )


OPEN(16, FILE = 'BR_DOT_ES_CENTRED.DAT', STATUS = 'REPLACE', FORM = 'FORMATTED')
OPEN(17, FILE = 'BR_ES_CENTRED.DAT', STATUS = 'REPLACE', FORM = 'FORMATTED')
OPEN(18, FILE = 'F_DOT_ES_CENTRED.DAT', STATUS = 'REPLACE', FORM = 'FORMATTED')
OPEN(19, FILE = 'BR_CS_CENTRED.DAT', STATUS = 'REPLACE', FORM = 'FORMATTED')

DO I_PHI = 1, NPHI_GRID_CONTOUR_GMT
DO I_THETA = 1, NTHETA_GRID_CONTOUR_GMT

PHI = -Pi + Pi /REAL(NPHI_GRID_CONTOUR_GMT, KIND = EXTRA_LONG_REAL) + 2.0 * Pi / REAL(NPHI_GRID_CONTOUR_GMT, KIND = EXTRA_LONG_REAL) * (I_PHI-1)
B_DOT_LOCATION(1:3) = 0.0_EXTRA_LONG_REAL
B_LOCATION(1:3) = 0.0_EXTRA_LONG_REAL

BR_CS = 0.0_8

DO I = 1, LMAX_SV * (LMAX_SV + 2)
! evaluate B and B_dot at Earth surface
IF( HARMONICS(I)%SINCOS .EQ. SINE_HARMONIC ) THEN
PHI_DEP = SIN(  HARMONICS(I)%M * PHI )
DERV_PHI_DEP = HARMONICS(I)%M * COS(  HARMONICS(I)%M * PHI )
ELSE
PHI_DEP = COS(  HARMONICS(I)%M * PHI )
DERV_PHI_DEP = -HARMONICS(I)%M * SIN(  HARMONICS(I)%M * PHI)
ENDIF

INDEX_PLM = HARMONICS(I)%M * LMAX_SV +  (HARMONICS(I)%M * (3-HARMONICS(I)%M) ) /2 + 1 + (HARMONICS(I)%L - HARMONICS(I)%M)
B_DOT_LOCATION(1) = B_DOT_LOCATION(1) + GAUSS_DOT(I) * ALF(I_THETA, INDEX_PLM) * PHI_DEP  * REAL(HARMONICS(I)%L + 1, KIND = EXTRA_LONG_REAL)
B_DOT_LOCATION(2) = B_DOT_LOCATION(2) - GAUSS_DOT(I) * DALF(I_THETA, INDEX_PLM) * PHI_DEP
B_DOT_LOCATION(3) = B_DOT_LOCATION(3) - GAUSS_DOT(I) * ALF(I_THETA, INDEX_PLM) * DERV_PHI_DEP * ONE_DIV_SIN_THETA(I_THETA)

IF( HARMONICS(I)%L .LE. LMAX_B ) THEN !SV goes to higher L than B[obs], so exclude if index goes higher than required.
B_LOCATION(1) = B_LOCATION(1) + GAUSS(I) *  ALF(I_THETA, INDEX_PLM) * PHI_DEP * REAL(HARMONICS(I)%L + 1, KIND = EXTRA_LONG_REAL)
B_LOCATION(2) = B_LOCATION(2) - GAUSS(I) * DALF(I_THETA, INDEX_PLM) * PHI_DEP
B_LOCATION(3) = B_LOCATION(3) - GAUSS(I) * ALF(I_THETA, INDEX_PLM) * DERV_PHI_DEP * ONE_DIV_SIN_THETA(I_THETA)

BR_CS = BR_CS + GAUSS(I) *  ALF(I_THETA, INDEX_PLM) * PHI_DEP * REAL(HARMONICS(I)%L + 1, KIND = EXTRA_LONG_REAL) * (ES_RADIUS / CMB_RADIUS)**(HARMONICS(I)%L+2)

ENDIF

ENDDO
WRITE(16,'(2F8.2,ES15.5)'), PHI*180.0/Pi ,90.0d0-ACOS(COSTHETA_GRID(I_THETA))*180.0/Pi,  B_DOT_LOCATION(1)
WRITE(17,'(2F8.2,ES15.5)'), PHI*180.0/Pi ,90.0d0-ACOS(COSTHETA_GRID(I_THETA))*180.0/Pi,  B_LOCATION(1)
WRITE(18,'(2F8.2,ES15.5)'), PHI*180.0/Pi ,90.0d0-ACOS(COSTHETA_GRID(I_THETA))*180.0/Pi,  SUM( B_DOT_LOCATION(:) * B_LOCATION(:) ) / SQRT( SUM( B_LOCATION(:)**2) )
ENDDO
ENDDO

CLOSE(16)
CLOSE(17)
CLOSE(18)

RETURN
END SUBROUTINE WRITE_BR_BR_DOT



    SUBROUTINE WRITE_B_R_DOT_GMT (GAUSS_DOT, GAUSS, LMAX_B, LMAX_SV, HARMONICS )
  IMPLICIT NONE
!  Units should be in nT/yr

  REAL( KIND = EXTRA_LONG_REAL) :: GAUSS_DOT(:), GAUSS(:)
  TYPE ( HARMONIC_STRUCTURE ) :: HARMONICS(1:)
  INTEGER :: LMAX_SV, LMAX_B

      REAL( KIND = EXTRA_LONG_REAL), ALLOCATABLE :: COSTHETA_GRID(:), ALF(:,:), DALF(:,:), ONE_DIV_SIN_THETA(:)
      REAL( KIND = EXTRA_LONG_REAL), ALLOCATABLE :: TEMP_THETA_TRANSFORM_ALF(:,:), TEMP_THETA_TRANSFORM_DALF(:,:)
      REAL( KIND = EXTRA_LONG_REAL) :: PHI,  PHI_DEP, DERV_PHI_DEP, B_DOT_CS, B_DOT_ES, B_CS, B_ES
      INTEGER :: I_THETA, I_PHI, I_HARMONIC, INDEX_PLM, I

  
! setup grids
      ALLOCATE( COSTHETA_GRID(1: NTHETA_GRID_CONTOUR_GMT))
      DO I_THETA = 1, NTHETA_GRID_CONTOUR_GMT
       COSTHETA_GRID(I_THETA) = COS(  I_THETA / REAL( NTHETA_GRID_CONTOUR_GMT + 1, KIND = EXTRA_LONG_REAL ) * Pi   )
      ENDDO

      ALLOCATE( TEMP_THETA_TRANSFORM_ALF(1: NTHETA_GRID_CONTOUR_GMT, (LMAX_SV + 1) * (LMAX_SV + 2)/2), TEMP_THETA_TRANSFORM_DALF(1: NTHETA_GRID_CONTOUR_GMT, (LMAX_SV + 1) * (LMAX_SV + 2)/2),ALF(1: NTHETA_GRID_CONTOUR_GMT, (LMAX_SV + 1) * (LMAX_SV + 2)/2), DALF(1: NTHETA_GRID_CONTOUR_GMT, (LMAX_SV + 1) * (LMAX_SV + 2)/2),  ONE_DIV_SIN_THETA(1: NTHETA_GRID_CONTOUR_GMT) )
      
       CALL GET_LEGENDRE_FUNCTIONS( REAL(COSTHETA_GRID, KIND = EXTRA_LONG_REAL), LMAX_SV, LMAX_SV, TEMP_THETA_TRANSFORM_ALF, TEMP_THETA_TRANSFORM_DALF) 
      ALF = REAL(  TEMP_THETA_TRANSFORM_ALF, KIND = EXTRA_LONG_REAL)
      DALF = REAL( TEMP_THETA_TRANSFORM_DALF, KIND = EXTRA_LONG_REAL)
      ONE_DIV_SIN_THETA(:) = 1.0_EXTRA_LONG_REAL / SQRT( 1.0_EXTRA_LONG_REAL - COSTHETA_GRID(:)**2 )

          
    OPEN(16, FILE = 'B_R_DOT_ES.DAT', STATUS = 'REPLACE', FORM = 'FORMATTED')
    OPEN(17, FILE = 'B_R_DOT_CS.DAT', STATUS = 'REPLACE', FORM = 'FORMATTED')
    OPEN(18, FILE = 'B_ES.DAT', STATUS = 'REPLACE', FORM = 'FORMATTED')
    OPEN(19, FILE = 'B_CS.DAT', STATUS = 'REPLACE', FORM = 'FORMATTED')
    DO I_PHI = 0, NPHI_GRID_CONTOUR_GMT-1
    DO I_THETA = 1, NTHETA_GRID_CONTOUR_GMT
    
    PHI =  I_PHI * 2.0_EXTRA_LONG_REAL * Pi / REAL(NPHI_GRID_CONTOUR_GMT, KIND = EXTRA_LONG_REAL)
    B_DOT_CS = 0.0_EXTRA_LONG_REAL
    B_DOT_ES = 0.0_EXTRA_LONG_REAL
    B_CS =  0.0_EXTRA_LONG_REAL
    B_ES= 0.0_EXTRA_LONG_REAL
    DO I = 1, LMAX_SV * (LMAX_SV + 2)
! evaluate B and B_dot at Earth surface
    IF( HARMONICS(I)%SINCOS .EQ. SINE_HARMONIC ) THEN
    PHI_DEP = SIN(  HARMONICS(I)%M * PHI )
    DERV_PHI_DEP = HARMONICS(I)%M * COS(  HARMONICS(I)%M * PHI )
    ELSE
    PHI_DEP = COS(  HARMONICS(I)%M * PHI )
    DERV_PHI_DEP = -HARMONICS(I)%M * SIN(  HARMONICS(I)%M * PHI)
    ENDIF

    INDEX_PLM = HARMONICS(I)%M * LMAX_SV +  (HARMONICS(I)%M * (3-HARMONICS(I)%M) ) /2 + 1 + (HARMONICS(I)%L - HARMONICS(I)%M)
    B_DOT_ES = B_DOT_ES + GAUSS_DOT(I) * ALF(I_THETA, INDEX_PLM) * PHI_DEP * REAL(HARMONICS(I)%L + 1, KIND = EXTRA_LONG_REAL)
    B_DOT_CS = B_DOT_CS + GAUSS_DOT(I) * ALF(I_THETA, INDEX_PLM) * PHI_DEP * REAL(HARMONICS(I)%L + 1, KIND = EXTRA_LONG_REAL) * (ES_RADIUS / CMB_RADIUS)**(HARMONICS(I)%L+2) 
    IF( HARMONICS(I)%L .LE. LMAX_B) THEN
    B_CS = B_CS + GAUSS(I) * ALF(I_THETA, INDEX_PLM) * PHI_DEP *  REAL(HARMONICS(I)%L + 1, KIND = EXTRA_LONG_REAL) * (ES_RADIUS / CMB_RADIUS)**(HARMONICS(I)%L+2) 
    B_ES = B_ES + GAUSS(I) * ALF(I_THETA, INDEX_PLM) * PHI_DEP * REAL(HARMONICS(I)%L + 1, KIND = EXTRA_LONG_REAL) 
    ENDIF

    ENDDO 
    WRITE(16,'(2F8.2,ES15.5)'), PHI*180.0/Pi ,90.0d0-ACOS(COSTHETA_GRID(I_THETA))*180.0/Pi, B_DOT_ES  
    WRITE(17,'(2F8.2,ES15.5)'), PHI*180.0/Pi ,90.0d0-ACOS(COSTHETA_GRID(I_THETA))*180.0/Pi, B_DOT_CS 
    WRITE(18,'(2F8.2,ES15.5)'), PHI*180.0/Pi ,90.0d0-ACOS(COSTHETA_GRID(I_THETA))*180.0/Pi, B_ES 
    WRITE(19,'(2F8.2,ES15.5)'), PHI*180.0/Pi ,90.0d0-ACOS(COSTHETA_GRID(I_THETA))*180.0/Pi, B_CS
    ENDDO
    ENDDO

!
    CLOSE(16)
    CLOSE(17)
    CLOSE(18)
    CLOSE(19)
        
    RETURN
    END SUBROUTINE WRITE_B_R_DOT_GMT


   SUBROUTINE FIND_SAA (GAUSS, LMAX_B, HARMONICS)
  IMPLICIT NONE
!  Units should be in nT

  REAL( KIND = EXTRA_LONG_REAL) :: GAUSS(:)
  TYPE ( HARMONIC_STRUCTURE ) :: HARMONICS(1:)
  INTEGER :: LMAX_B, NTHETA_GRID, NPHI_GRID

      REAL( KIND = EXTRA_LONG_REAL), ALLOCATABLE :: COSTHETA_GRID(:), ALF(:,:), DALF(:,:), ONE_DIV_SIN_THETA(:)
      REAL( KIND = EXTRA_LONG_REAL), ALLOCATABLE :: TEMP_THETA_TRANSFORM_ALF(:,:), TEMP_THETA_TRANSFORM_DALF(:,:)
      REAL( KIND = EXTRA_LONG_REAL) :: PHI,  PHI_DEP, DERV_PHI_DEP, B(1:3), THETA_MIN, PHI_MIN, F, F_MIN
      INTEGER :: I_THETA, I_PHI, I_HARMONIC, INDEX_PLM, I

     NTHETA_GRID = 179
     NPHI_GRID = 360

! setup grids
      ALLOCATE( COSTHETA_GRID(1: NTHETA_GRID))
      DO I_THETA = 1, NTHETA_GRID
       COSTHETA_GRID(I_THETA) = COS(  I_THETA / REAL( NTHETA_GRID + 1, KIND = EXTRA_LONG_REAL ) * Pi   )
      ENDDO

      ALLOCATE( TEMP_THETA_TRANSFORM_ALF(1: NTHETA_GRID, (LMAX_B + 1) * (LMAX_B + 2)/2), TEMP_THETA_TRANSFORM_DALF(1: NTHETA_GRID, (LMAX_B + 1) * (LMAX_B + 2)/2),ALF(1: NTHETA_GRID, (LMAX_B + 1) * (LMAX_B + 2)/2), DALF(1: NTHETA_GRID, (LMAX_B + 1) * (LMAX_B + 2)/2),  ONE_DIV_SIN_THETA(1: NTHETA_GRID) )
      
       CALL GET_LEGENDRE_FUNCTIONS( REAL(COSTHETA_GRID, KIND = EXTRA_LONG_REAL), LMAX_B, LMAX_B, TEMP_THETA_TRANSFORM_ALF, TEMP_THETA_TRANSFORM_DALF) 
      ALF = REAL(  TEMP_THETA_TRANSFORM_ALF, KIND = EXTRA_LONG_REAL)
      DALF = REAL( TEMP_THETA_TRANSFORM_DALF, KIND = EXTRA_LONG_REAL)
      ONE_DIV_SIN_THETA(:) = 1.0_EXTRA_LONG_REAL / SQRT( 1.0_EXTRA_LONG_REAL - COSTHETA_GRID(:)**2 )

          
    THETA_MIN = -1
    PHI_MIN = -1
    F_MIN = 1.0e10

    DO I_PHI = 0, NPHI_GRID-1
    DO I_THETA = 1, NTHETA_GRID
    B(1:3) = 0.0_EXTRA_LONG_REAL

    PHI =  I_PHI * 2.0_EXTRA_LONG_REAL * Pi / REAL(NPHI_GRID, KIND = EXTRA_LONG_REAL)
    
    DO I = 1, LMAX_B * (LMAX_B + 2)
! evaluate B and B_dot at Earth surface
    IF( HARMONICS(I)%SINCOS .EQ. SINE_HARMONIC ) THEN
    PHI_DEP = SIN(  HARMONICS(I)%M * PHI )
    DERV_PHI_DEP = HARMONICS(I)%M * COS(  HARMONICS(I)%M * PHI )
    ELSE
    PHI_DEP = COS(  HARMONICS(I)%M * PHI )
    DERV_PHI_DEP = -HARMONICS(I)%M * SIN(  HARMONICS(I)%M * PHI)
    ENDIF
 
    INDEX_PLM = HARMONICS(I)%M * LMAX_B +  (HARMONICS(I)%M * (3-HARMONICS(I)%M) ) /2 + 1 + (HARMONICS(I)%L - HARMONICS(I)%M)
    B(1) = B(1) + GAUSS(I) *  ALF(I_THETA, INDEX_PLM) * PHI_DEP * REAL(HARMONICS(I)%L + 1, KIND = EXTRA_LONG_REAL)   
    B(2) = B(2) - GAUSS(I) * DALF(I_THETA, INDEX_PLM) * PHI_DEP  
    B(3) = B(3) - GAUSS(I) * ALF(I_THETA, INDEX_PLM) * DERV_PHI_DEP * ONE_DIV_SIN_THETA(I_THETA) 
    F = SQRT( SUM(B(:)**2) )
    IF( F < F_MIN ) THEN
    F_MIN = F
    THETA_MIN =  I_THETA / REAL( NTHETA_GRID + 1, KIND = EXTRA_LONG_REAL ) * 180 
    PHI_MIN = PHI / Pi * 180.0
    ENDIF

    ENDDO 
    
    ENDDO
    ENDDO


    PRINT*, 'TO NEAREST DEGREE, SAA HAS COLATITUDE/LONGITUDE:'
    PRINT*, THETA_MIN, PHI_MIN
    PRINT*, 'AND HAS AN INTENSITY OF ', F_MIN
    RETURN
    END SUBROUTINE FIND_SAA


   


   END MODULE SUBS
